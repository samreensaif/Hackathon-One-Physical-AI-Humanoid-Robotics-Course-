"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[4742],{1607(n,e,a){a.r(e),a.d(e,{assets:()=>d,contentTitle:()=>c,default:()=>u,frontMatter:()=>s,metadata:()=>o,toc:()=>p});const o=JSON.parse('{"id":"module3-isaac/chapter4","title":"Chapter 4: Nav2 and Path Planning for Humanoids","description":"Learning Objectives","source":"@site/docs/module3-isaac/chapter4.mdx","sourceDirName":"module3-isaac","slug":"/module3-isaac/chapter4","permalink":"/Hackathon-One-Physical-AI-Humanoid-Robotics-Course-/ur/docs/module3-isaac/chapter4","draft":false,"unlisted":false,"editUrl":"https://github.com/samreensaif/Hackathon-One-Physical-AI-Humanoid-Robotics-Course-/tree/main/physical-ai-textbook/docs/module3-isaac/chapter4.mdx","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Chapter 4: Nav2 and Path Planning for Humanoids","sidebar_position":4,"gpu_required":true},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 3: Isaac ROS and Visual SLAM","permalink":"/Hackathon-One-Physical-AI-Humanoid-Robotics-Course-/ur/docs/module3-isaac/chapter3"},"next":{"title":"Chapter 1: Introduction to Vision-Language-Action Models","permalink":"/Hackathon-One-Physical-AI-Humanoid-Robotics-Course-/ur/docs/module4-vla/chapter1"}}');var t=a(4848),i=a(8453),r=a(7132),l=a(20);const s={title:"Chapter 4: Nav2 and Path Planning for Humanoids",sidebar_position:4,gpu_required:!0},c="Chapter 4: Nav2 and Path Planning for Humanoid Robots",d={},p=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"4.1 Navigation: The Full Problem",id:"41-navigation-the-full-problem",level:2},{value:"4.2 The Nav2 Architecture",id:"42-the-nav2-architecture",level:2},{value:"The Behaviour Tree",id:"the-behaviour-tree",level:3},{value:"4.3 Costmaps",id:"43-costmaps",level:2},{value:"Global Costmap",id:"global-costmap",level:3},{value:"Local Costmap",id:"local-costmap",level:3},{value:"Costmap Configuration for a Humanoid",id:"costmap-configuration-for-a-humanoid",level:3},{value:"4.4 Global Path Planners",id:"44-global-path-planners",level:2},{value:"NavFn (Dijkstra / A*)",id:"navfn-dijkstra--a",level:3},{value:"Smac Planner (Hybrid A*)",id:"smac-planner-hybrid-a",level:3},{value:"4.5 Local Trajectory Planners",id:"45-local-trajectory-planners",level:2},{value:"DWB (Dynamic Window Approach with Critics)",id:"dwb-dynamic-window-approach-with-critics",level:3},{value:"Regulated Pure Pursuit (RPP)",id:"regulated-pure-pursuit-rpp",level:3},{value:"4.6 Humanoid-Specific Navigation Challenges",id:"46-humanoid-specific-navigation-challenges",level:2},{value:"1. Non-Holonomic vs Quasi-Holonomic Motion",id:"1-non-holonomic-vs-quasi-holonomic-motion",level:3},{value:"2. Footstep Planning",id:"2-footstep-planning",level:3},{value:"3. Variable-Width Footprint",id:"3-variable-width-footprint",level:3},{value:"4. Velocity Command Translation",id:"4-velocity-command-translation",level:3},{value:"4.7 Sending Navigation Goals Programmatically",id:"47-sending-navigation-goals-programmatically",level:2},{value:"Sending a Sequence of Waypoints",id:"sending-a-sequence-of-waypoints",level:3},{value:"4.8 Complete Nav2 Configuration File",id:"48-complete-nav2-configuration-file",level:2},{value:"4.9 Launching the Full Navigation Stack",id:"49-launching-the-full-navigation-stack",level:2},{value:"4.10 Chapter Summary",id:"410-chapter-summary",level:2},{value:"Module 3 Summary",id:"module-3-summary",level:2},{value:"Review Questions",id:"review-questions",level:2}];function h(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.A,{}),"\n",(0,t.jsx)(l.A,{}),"\n",(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"chapter-4-nav2-and-path-planning-for-humanoid-robots",children:"Chapter 4: Nav2 and Path Planning for Humanoid Robots"})}),"\n",(0,t.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsx)(e.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Describe the Nav2 stack architecture and the role of each component"}),"\n",(0,t.jsx)(e.li,{children:"Explain global and local costmaps and configure them for a humanoid robot footprint"}),"\n",(0,t.jsx)(e.li,{children:"Distinguish between global path planners (NavFn, Smac) and local trajectory planners (DWB, TEB)"}),"\n",(0,t.jsx)(e.li,{children:"Identify the unique challenges of bipedal navigation compared to wheeled robots"}),"\n",(0,t.jsx)(e.li,{children:"Integrate VSLAM odometry and Nvblox occupancy maps with the Nav2 stack"}),"\n",(0,t.jsx)(e.li,{children:"Send navigation goals programmatically via the Nav2 action API in Python"}),"\n",(0,t.jsx)(e.li,{children:"Configure recovery behaviours for stuck and lost scenarios"}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"41-navigation-the-full-problem",children:"4.1 Navigation: The Full Problem"}),"\n",(0,t.jsx)(e.p,{children:"A navigating robot must solve three sub-problems simultaneously:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Navigation Problem                                             \u2502\n\u2502                                                                 \u2502\n\u2502  1. WHERE AM I?         \u2192 Localisation (VSLAM / AMCL / EKF)   \u2502\n\u2502                                                                 \u2502\n\u2502  2. WHAT'S AROUND ME?   \u2192 Mapping (Nvblox / costmap)          \u2502\n\u2502                                                                 \u2502\n\u2502  3. HOW DO I GET THERE? \u2192 Path planning + trajectory control   \u2502\n\u2502        \u2022 Global planner: compute a path through free space     \u2502\n\u2502        \u2022 Local planner: follow the path while avoiding         \u2502\n\u2502          dynamic obstacles                                      \u2502\n\u2502        \u2022 Controller: convert velocity commands to              \u2502\n\u2502          actuator outputs                                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Nav2"})," (Navigation2) is the ROS 2 navigation stack that solves sub-problem 3. It is modular, plugin-based, and designed to work with any robot that can publish odometry and receive ",(0,t.jsx)(e.code,{children:"Twist"})," velocity commands."]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"42-the-nav2-architecture",children:"4.2 The Nav2 Architecture"}),"\n",(0,t.jsx)(e.p,{children:"Nav2 consists of several servers, each running as a lifecycle-managed ROS 2 node (recall the lifecycle from Chapter 1 of Module 1):"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            \u2502        Navigation Goal (Action)         \u2502\n            \u2502    /navigate_to_pose, /navigate_through \u2502\n            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                             \u2502\n                             \u25bc\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502  BT Navigator   \u2502     Behaviour Tree\n                    \u2502  (orchestrator) \u2502     controls the navigation\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     state machine\n                             \u2502\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u25bc              \u25bc              \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502   Planner    \u2502 \u2502  Controller  \u2502 \u2502   Recoveries \u2502\n    \u2502   Server     \u2502 \u2502   Server     \u2502 \u2502   Server     \u2502\n    \u2502 (global path)\u2502 \u2502 (local traj) \u2502 \u2502 (stuck/lost) \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502                \u2502                \u2502\n           \u25bc                \u25bc                \u25bc\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502              Costmap 2D                          \u2502\n   \u2502  (global costmap)    (local costmap)             \u2502\n   \u2502  Inflation layer     Obstacle layer              \u2502\n   \u2502  Static map layer    Voxel layer (3D\u21922D)         \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502                \u2502\n           \u25bc                \u25bc\n     /map (OccGrid)   /scan or /depth\n"})}),"\n",(0,t.jsx)(e.h3,{id:"the-behaviour-tree",children:"The Behaviour Tree"}),"\n",(0,t.jsxs)(e.p,{children:["Nav2's ",(0,t.jsx)(e.strong,{children:"Behaviour Tree (BT)"})," navigator orchestrates the planning, control, and recovery steps. It is a tree of conditional and action nodes that defines the high-level navigation policy:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Default nav2 behaviour tree (simplified) --\x3e\n<root main_tree_to_execute="MainTree">\n  <BehaviorTree ID="MainTree">\n    <RecoveryNode number_of_retries="6" name="NavigateWithReplanning">\n\n      \x3c!-- Main action: compute global path, then follow it --\x3e\n      <PipelineSequence name="NavigateWithReplanning">\n        <RateController hz="1.0">\n          <ComputePathToPose goal="{goal}" path="{path}" />\n        </RateController>\n        <FollowPath path="{path}" controller_id="FollowPath" />\n      </PipelineSequence>\n\n      \x3c!-- Recovery: if stuck, try spinning, backing up, etc. --\x3e\n      <ReactiveFallback name="RecoveryFallback">\n        <GoalUpdated/>\n        <RoundRobin name="RecoveryActions">\n          <Sequence name="ClearingActions">\n            <ClearEntireCostmap server_name="local_costmap/clear_entirely_local_costmap"/>\n            <ClearEntireCostmap server_name="global_costmap/clear_entirely_global_costmap"/>\n          </Sequence>\n          <Spin spin_dist="1.57" />\n          <Wait wait_duration="5" />\n          <BackUp backup_dist="0.30" backup_speed="0.05" />\n        </RoundRobin>\n      </ReactiveFallback>\n\n    </RecoveryNode>\n  </BehaviorTree>\n</root>\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"43-costmaps",children:"4.3 Costmaps"}),"\n",(0,t.jsxs)(e.p,{children:["A ",(0,t.jsx)(e.strong,{children:"costmap"})," is a 2D grid where each cell holds a cost value from 0 (free) to 254 (lethal obstacle). The planner searches this grid for a path from start to goal."]}),"\n",(0,t.jsx)(e.p,{children:"Nav2 uses two costmaps:"}),"\n",(0,t.jsx)(e.h3,{id:"global-costmap",children:"Global Costmap"}),"\n",(0,t.jsxs)(e.p,{children:["The global costmap covers the entire known environment. It is updated slowly (on the order of 0.5\u20131 Hz) and is used by the ",(0,t.jsx)(e.strong,{children:"global planner"})," to compute the initial path."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Cell values:\n  0          = Free space (robot can traverse)\n  1\u2013252      = Inflation (penalty zone around obstacles)\n  253        = Inscribed (inside robot footprint radius \u2014 forbidden)\n  254        = Lethal (occupied by an obstacle)\n  255        = Unknown (not yet observed)\n"})}),"\n",(0,t.jsx)(e.h3,{id:"local-costmap",children:"Local Costmap"}),"\n",(0,t.jsxs)(e.p,{children:["The local costmap is a smaller window around the robot (e.g., 3\xd73 metres), updated at 10 Hz or faster. It is used by the ",(0,t.jsx)(e.strong,{children:"local planner"})," to track the global path while reacting to dynamic obstacles (people walking by, fallen objects)."]}),"\n",(0,t.jsx)(e.h3,{id:"costmap-configuration-for-a-humanoid",children:"Costmap Configuration for a Humanoid"}),"\n",(0,t.jsx)(e.p,{children:"A wheeled robot's footprint is typically circular. A humanoid's footprint depends on its stance and can be modelled as a rectangle:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:'# nav2_params.yaml \u2014 costmap section for a humanoid\n\nglobal_costmap:\n  global_costmap:\n    ros__parameters:\n      update_frequency: 0.5        # Hz \u2014 slow, uses static map\n      publish_frequency: 1.0\n      global_frame: map\n      robot_base_frame: base_link\n      resolution: 0.05             # 5 cm/cell\n\n      # Humanoid footprint: 40cm wide, 30cm deep (conservative)\n      footprint: >-\n        [[-0.15, -0.20], [-0.15, 0.20],\n         [0.15, 0.20], [0.15, -0.20]]\n\n      plugins: ["static_layer", "inflation_layer"]\n\n      static_layer:\n        plugin: "nav2_costmap_2d::StaticLayer"\n        map_subscribe_transient_local: True\n\n      inflation_layer:\n        plugin: "nav2_costmap_2d::InflationLayer"\n        inflation_radius: 0.55     # Must be > robot radius (0.28m for humanoid)\n        cost_scaling_factor: 3.0   # Exponential decay of costs\n\nlocal_costmap:\n  local_costmap:\n    ros__parameters:\n      update_frequency: 10.0       # Hz \u2014 fast, reacts to dynamic obstacles\n      publish_frequency: 10.0\n      global_frame: odom\n      robot_base_frame: base_link\n      rolling_window: true\n      width: 3.5                   # Metres\n      height: 3.5\n      resolution: 0.05\n\n      # Same footprint\n      footprint: >-\n        [[-0.15, -0.20], [-0.15, 0.20],\n         [0.15, 0.20], [0.15, -0.20]]\n\n      plugins: ["obstacle_layer", "inflation_layer"]\n\n      obstacle_layer:\n        plugin: "nav2_costmap_2d::ObstacleLayer"\n        enabled: True\n        observation_sources: scan\n        scan:\n          topic: /scan\n          max_obstacle_height: 2.0\n          clearing: True\n          marking: True\n          data_type: "LaserScan"\n          raytrace_max_range: 5.0\n          raytrace_min_range: 0.0\n          obstacle_max_range: 4.5\n          obstacle_min_range: 0.0\n\n      inflation_layer:\n        plugin: "nav2_costmap_2d::InflationLayer"\n        inflation_radius: 0.55\n        cost_scaling_factor: 3.0\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"44-global-path-planners",children:"4.4 Global Path Planners"}),"\n",(0,t.jsxs)(e.p,{children:["The ",(0,t.jsx)(e.strong,{children:"global planner"})," computes an obstacle-free path from the robot's current position to the goal on the global costmap. Nav2 provides several plugin implementations:"]}),"\n",(0,t.jsx)(e.h3,{id:"navfn-dijkstra--a",children:"NavFn (Dijkstra / A*)"}),"\n",(0,t.jsx)(e.p,{children:"The original ROS global planner. Uses A* (or Dijkstra) to find the shortest path on the costmap grid."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:'planner_server:\n  ros__parameters:\n    planner_plugins: ["GridBased"]\n    GridBased:\n      plugin: "nav2_navfn_planner/NavfnPlanner"\n      tolerance: 0.5       # Acceptable goal distance error (metres)\n      use_astar: true      # True = A*, False = Dijkstra\n      allow_unknown: true  # Can plan through unknown cells\n'})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Pros"}),": Fast, well-tested, simple. ",(0,t.jsx)(e.strong,{children:"Cons"}),": Only 8-connected (45\xb0 angle resolution), ignores kinematic constraints."]}),"\n",(0,t.jsx)(e.h3,{id:"smac-planner-hybrid-a",children:"Smac Planner (Hybrid A*)"}),"\n",(0,t.jsxs)(e.p,{children:["The ",(0,t.jsx)(e.strong,{children:"Smac Planner"})," family is Nav2's modern alternative. It uses ",(0,t.jsx)(e.strong,{children:"Hybrid A"}),"* \u2014 a search that respects the robot's turning radius and produces smooth, kinematically feasible paths."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:'planner_server:\n  ros__parameters:\n    planner_plugins: ["GridBased"]\n    GridBased:\n      plugin: "nav2_smac_planner/SmacPlannerHybrid"\n      downsample_costmap: false\n      downsampling_factor: 1\n      tolerance: 0.25\n      allow_unknown: true\n      max_iterations: 1000000\n\n      # Kinematic constraints for a humanoid walking in 2D\n      minimum_turning_radius: 0.2  # metres \u2014 humanoids turn ~in-place\n      reverse_penalty: 2.0         # Penalise walking backwards\n      change_penalty: 0.0\n      non_straight_penalty: 1.2\n\n      # Analytic expansion for faster goal connection\n      analytic_expansion_ratio: 3.5\n      analytic_expansion_max_length: 3.0\n\n      # Lattice planner settings (for non-holonomic)\n      motion_model_for_search: "REEDS_SHEPP"  # or "DUBIN" for forward-only\n'})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Pros"}),": Smooth paths, respects turning radius, better for narrow corridors. ",(0,t.jsx)(e.strong,{children:"Cons"}),": Slower than NavFn (but usually still sub-second)."]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"45-local-trajectory-planners",children:"4.5 Local Trajectory Planners"}),"\n",(0,t.jsxs)(e.p,{children:["The ",(0,t.jsx)(e.strong,{children:"local planner"}),' (called the "controller" in Nav2) tracks the global path in real-time, adjusting for dynamic obstacles and robot dynamics.']}),"\n",(0,t.jsx)(e.h3,{id:"dwb-dynamic-window-approach-with-critics",children:"DWB (Dynamic Window Approach with Critics)"}),"\n",(0,t.jsxs)(e.p,{children:["DWB simulates many possible velocity commands forward in time, evaluates each with a set of ",(0,t.jsx)(e.strong,{children:"critic functions"}),", and selects the command that scores best."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  DWB Planning Cycle (10\u201320 Hz)                  \u2502\n\u2502                                                 \u2502\n\u2502  1. Sample velocity space (v, \u03c9) pairs          \u2502\n\u2502  2. Simulate trajectories for each sample       \u2502\n\u2502  3. Score each with critics:                    \u2502\n\u2502     \u2022 PathAlign:  is trajectory following path? \u2502\n\u2502     \u2022 GoalAlign:  pointing toward goal?         \u2502\n\u2502     \u2022 PathDist:   distance to global path       \u2502\n\u2502     \u2022 GoalDist:   distance to goal              \u2502\n\u2502     \u2022 Oscillation: penalise direction reversals \u2502\n\u2502     \u2022 Obstacle:  penalty for nearness to walls  \u2502\n\u2502  4. Select highest-scoring safe trajectory      \u2502\n\u2502  5. Publish first velocity command from it      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:'controller_server:\n  ros__parameters:\n    controller_plugins: ["FollowPath"]\n    controller_frequency: 20.0    # Hz\n\n    FollowPath:\n      plugin: "dwb_core::DWBLocalPlanner"\n\n      # Velocity limits \u2014 must match actual robot capabilities\n      min_vel_x: -0.10            # Allow backing up slowly\n      max_vel_x: 0.50             # Maximum forward speed (m/s)\n      min_vel_y: 0.0              # Non-holonomic: no lateral movement\n      max_vel_y: 0.0\n      max_vel_theta: 1.0          # Maximum rotation speed (rad/s)\n      min_speed_xy: 0.0\n      max_speed_xy: 0.50\n\n      # Acceleration limits \u2014 humanoid gait constraints\n      acc_lim_x: 0.5              # m/s\xb2 \u2014 gentle acceleration\n      acc_lim_y: 0.0\n      acc_lim_theta: 2.5          # rad/s\xb2\n      decel_lim_x: -0.5\n\n      # Trajectory simulation\n      sim_time: 1.7               # Seconds to simulate forward\n      sim_granularity: 0.025      # Metres between simulated points\n      angular_sim_granularity: 0.025\n\n      # Goal tolerance\n      xy_goal_tolerance: 0.25     # Metres\n      yaw_goal_tolerance: 0.25    # Radians (~14\xb0)\n\n      # Critic weights\n      critics: ["RotateToGoal", "Oscillation", "BaseObstacle",\n                "GoalAlign", "PathAlign", "PathDist", "GoalDist"]\n      BaseObstacle.scale: 0.02\n      PathAlign.scale: 32.0\n      PathAlign.forward_point_distance: 0.1\n      GoalAlign.scale: 24.0\n      GoalAlign.forward_point_distance: 0.1\n      PathDist.scale: 32.0\n      GoalDist.scale: 24.0\n      RotateToGoal.scale: 32.0\n      RotateToGoal.slowing_factor: 5.0\n      RotateToGoal.lookahead_time: -1.0\n'})}),"\n",(0,t.jsx)(e.h3,{id:"regulated-pure-pursuit-rpp",children:"Regulated Pure Pursuit (RPP)"}),"\n",(0,t.jsxs)(e.p,{children:["For holonomic robots or simpler scenarios, ",(0,t.jsx)(e.strong,{children:"Regulated Pure Pursuit"})," is a lightweight controller that follows the path by steering toward a lookahead point:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:'FollowPath:\n  plugin: "nav2_regulated_pure_pursuit_controller::RegulatedPurePursuitController"\n  desired_linear_vel: 0.4\n  lookahead_dist: 0.6\n  min_lookahead_dist: 0.3\n  max_lookahead_dist: 0.9\n  lookahead_time: 1.5\n  rotate_to_heading_angular_vel: 1.0\n  use_velocity_scaled_lookahead_dist: true\n  min_approach_linear_velocity: 0.05\n  max_allowed_time_to_collision_up_to_carrot: 1.0\n  use_regulated_linear_velocity_scaling: true\n  use_cost_regulated_linear_velocity_scaling: false\n  regulated_linear_scaling_min_radius: 0.9\n  regulated_linear_scaling_min_speed: 0.25\n  use_rotate_to_heading: true    # Rotate in-place to face goal direction\n  allow_reversing: false\n  rotate_to_heading_min_angle: 0.785\n  max_angular_accel: 2.0\n  max_robot_pose_search_dist: 10.0\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"46-humanoid-specific-navigation-challenges",children:"4.6 Humanoid-Specific Navigation Challenges"}),"\n",(0,t.jsx)(e.p,{children:"Wheeled robots and bipedal humanoids share much of the same navigation stack, but bipedal locomotion introduces unique considerations."}),"\n",(0,t.jsx)(e.h3,{id:"1-non-holonomic-vs-quasi-holonomic-motion",children:"1. Non-Holonomic vs Quasi-Holonomic Motion"}),"\n",(0,t.jsxs)(e.p,{children:["Wheeled differential-drive robots cannot move sideways. Most modern humanoid robots can take side-steps, making them ",(0,t.jsx)(e.strong,{children:"quasi-holonomic"})," \u2014 they can walk in any horizontal direction, though forward walking is most efficient."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:'# For a humanoid with side-stepping capability:\nFollowPath:\n  plugin: "dwb_core::DWBLocalPlanner"\n  min_vel_y: -0.20     # Allow side-stepping left\n  max_vel_y:  0.20     # Allow side-stepping right\n  # This requires a holonomic costmap footprint check!\n'})}),"\n",(0,t.jsx)(e.h3,{id:"2-footstep-planning",children:"2. Footstep Planning"}),"\n",(0,t.jsxs)(e.p,{children:["For rough terrain, slopes, and stairs, 2D costmap navigation is insufficient. The robot must plan ",(0,t.jsx)(e.strong,{children:"individual footstep placements"})," in 3D:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"2D Costmap Planning:\n  Robot \u2192 Goal\n  Path avoids 2D obstacles\n  Ignores terrain height variations\n\nFootstep Planning:\n  Robot \u2192 Goal\n  Each foot is placed explicitly on a valid surface\n  Handles stairs, slopes, stepping stones\n  Much more computationally expensive\n"})}),"\n",(0,t.jsxs)(e.p,{children:["A full footstep planner (like ",(0,t.jsx)(e.strong,{children:"IHMC Footstep Planner"})," or ",(0,t.jsx)(e.strong,{children:"OCS2"}),") is beyond the scope of this chapter, but the interface to Nav2 is a custom ",(0,t.jsx)(e.strong,{children:"global planner plugin"})," that outputs a list of ",(0,t.jsx)(e.code,{children:"geometry_msgs/Pose"})," footstep poses."]}),"\n",(0,t.jsx)(e.h3,{id:"3-variable-width-footprint",children:"3. Variable-Width Footprint"}),"\n",(0,t.jsx)(e.p,{children:"During walking, a humanoid's footprint is not fixed \u2014 it changes with gait phase:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Stance phase (double support):   both feet on ground \u2192 wide footprint\nSwing phase (single support):    one foot in air    \u2192 narrow footprint\n"})}),"\n",(0,t.jsxs)(e.p,{children:["Nav2 supports ",(0,t.jsx)(e.strong,{children:"footprint inflation"})," and ",(0,t.jsx)(e.strong,{children:"footprint topic"})," (dynamic footprint update):"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:"local_costmap:\n  local_costmap:\n    ros__parameters:\n      # Subscribe to dynamic footprint updates\n      footprint_topic: /local_footprint\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'# Publish updated footprint based on gait phase\nfrom geometry_msgs.msg import Polygon, Point32\n\nclass FootprintPublisher(Node):\n    def __init__(self):\n        super().__init__(\'footprint_publisher\')\n        self.pub = self.create_publisher(\n            Polygon, \'/local_footprint\', 10\n        )\n\n    def publish_stance_footprint(self):\n        """Wide footprint during double support."""\n        poly = Polygon()\n        for x, y in [(-0.15, -0.30), (-0.15, 0.30),\n                     (0.15, 0.30), (0.15, -0.30)]:\n            p = Point32()\n            p.x, p.y, p.z = x, y, 0.0\n            poly.points.append(p)\n        self.pub.publish(poly)\n\n    def publish_swing_footprint(self):\n        """Narrow footprint during single support."""\n        poly = Polygon()\n        for x, y in [(-0.10, -0.15), (-0.10, 0.15),\n                     (0.10, 0.15), (0.10, -0.15)]:\n            p = Point32()\n            p.x, p.y, p.z = x, y, 0.0\n            poly.points.append(p)\n        self.pub.publish(poly)\n'})}),"\n",(0,t.jsx)(e.h3,{id:"4-velocity-command-translation",children:"4. Velocity Command Translation"}),"\n",(0,t.jsxs)(e.p,{children:["Nav2 outputs ",(0,t.jsx)(e.code,{children:"geometry_msgs/Twist"})," commands (linear velocity + angular velocity). For a wheeled robot, these map directly to wheel speeds. For a humanoid, they must be translated to a ",(0,t.jsx)(e.strong,{children:"walking gait command"}),":"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Nav2 Twist output:\n  linear.x = 0.3 m/s   (forward velocity)\n  angular.z = 0.5 rad/s (turning rate)\n\nHumanoid Gait Controller input:\n  forward_speed = 0.3 m/s\n  lateral_speed = 0.0 m/s\n  turning_rate  = 0.5 rad/s\n  gait_mode     = WALK (vs STAND, CROUCH, RUN)\n"})}),"\n",(0,t.jsxs)(e.p,{children:["A ",(0,t.jsx)(e.strong,{children:"Twist \u2192 Gait"})," bridge node sits between Nav2 and the humanoid's locomotion controller:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"# twist_to_gait_node.py\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist\nfrom std_msgs.msg import Float32MultiArray\n\nclass TwistToGaitNode(Node):\n    \"\"\"\n    Converts Nav2 Twist commands to humanoid gait parameters.\n    Sits between /cmd_vel (Nav2 output) and the gait controller.\n    \"\"\"\n\n    # Gait mode thresholds\n    WALK_THRESHOLD = 0.05    # m/s \u2014 below this, just rotate in place\n\n    def __init__(self):\n        super().__init__('twist_to_gait')\n\n        self.cmd_sub = self.create_subscription(\n            Twist, '/cmd_vel', self.cmd_vel_callback, 10\n        )\n\n        # Publish to the gait controller\n        # Format: [forward_speed, lateral_speed, turning_rate, gait_mode]\n        # gait_mode: 0=STAND, 1=WALK, 2=RUN\n        self.gait_pub = self.create_publisher(\n            Float32MultiArray, '/gait_controller/command', 10\n        )\n\n        self.get_logger().info('Twist-to-Gait bridge started.')\n\n    def cmd_vel_callback(self, msg: Twist):\n        forward  = msg.linear.x\n        lateral  = msg.linear.y\n        turn_rate = msg.angular.z\n\n        speed = (forward**2 + lateral**2) ** 0.5\n\n        # Determine gait mode\n        if speed < self.WALK_THRESHOLD and abs(turn_rate) < 0.1:\n            gait_mode = 0  # STAND\n        else:\n            gait_mode = 1  # WALK\n\n        gait_cmd = Float32MultiArray()\n        gait_cmd.data = [\n            float(forward),\n            float(lateral),\n            float(turn_rate),\n            float(gait_mode),\n        ]\n\n        self.gait_pub.publish(gait_cmd)\n\n        if gait_mode == 1:\n            self.get_logger().debug(\n                f'WALK: fwd={forward:.2f} lat={lateral:.2f} '\n                f'turn={turn_rate:.2f}'\n            )\n        else:\n            self.get_logger().debug('STAND: zero velocity.')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = TwistToGaitNode()\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"47-sending-navigation-goals-programmatically",children:"4.7 Sending Navigation Goals Programmatically"}),"\n",(0,t.jsxs)(e.p,{children:["In Module 1, we used ROS 2 services and topics. Navigation goals use ",(0,t.jsx)(e.strong,{children:"ROS 2 Actions"})," \u2014 the mechanism for long-running tasks with feedback. The full ",(0,t.jsx)(e.code,{children:"NavigateToPose"})," action client:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"# nav2_goal_sender.py\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.action import ActionClient\nfrom nav2_msgs.action import NavigateToPose\nfrom geometry_msgs.msg import PoseStamped, Quaternion\nimport math\n\ndef euler_to_quaternion(yaw: float) -> Quaternion:\n    \"\"\"Convert a yaw angle (radians) to a ROS Quaternion.\"\"\"\n    q = Quaternion()\n    q.x = 0.0\n    q.y = 0.0\n    q.z = math.sin(yaw / 2.0)\n    q.w = math.cos(yaw / 2.0)\n    return q\n\nclass Nav2GoalSender(Node):\n    \"\"\"Sends navigation goals to the Nav2 stack and monitors progress.\"\"\"\n\n    def __init__(self):\n        super().__init__('nav2_goal_sender')\n        self._action_client = ActionClient(\n            self,\n            NavigateToPose,\n            'navigate_to_pose'\n        )\n\n    def send_goal(self, x: float, y: float, yaw: float):\n        \"\"\"\n        Send a 2D navigation goal.\n        x, y: target position in the map frame (metres)\n        yaw:  target heading (radians, 0 = facing positive X)\n        \"\"\"\n        self.get_logger().info(\n            f'Waiting for Nav2 action server...'\n        )\n        self._action_client.wait_for_server()\n\n        goal_msg = NavigateToPose.Goal()\n        goal_msg.pose = PoseStamped()\n        goal_msg.pose.header.frame_id = 'map'\n        goal_msg.pose.header.stamp = self.get_clock().now().to_msg()\n        goal_msg.pose.pose.position.x = float(x)\n        goal_msg.pose.pose.position.y = float(y)\n        goal_msg.pose.pose.position.z = 0.0\n        goal_msg.pose.pose.orientation = euler_to_quaternion(yaw)\n\n        self.get_logger().info(\n            f'Sending goal: ({x:.2f}, {y:.2f}), yaw={math.degrees(yaw):.1f}\xb0'\n        )\n\n        send_goal_future = self._action_client.send_goal_async(\n            goal_msg,\n            feedback_callback=self.feedback_callback\n        )\n        send_goal_future.add_done_callback(self.goal_response_callback)\n\n    def goal_response_callback(self, future):\n        goal_handle = future.result()\n        if not goal_handle.accepted:\n            self.get_logger().error('Goal rejected by Nav2!')\n            return\n\n        self.get_logger().info('Goal accepted.')\n        result_future = goal_handle.get_result_async()\n        result_future.add_done_callback(self.result_callback)\n\n    def feedback_callback(self, feedback_msg):\n        \"\"\"Called periodically while the robot navigates.\"\"\"\n        fb = feedback_msg.feedback\n        remaining = fb.distance_remaining\n        self.get_logger().info(\n            f'Distance remaining: {remaining:.2f} m'\n        )\n\n    def result_callback(self, future):\n        result = future.result().result\n        status = future.result().status\n\n        if status == 4:  # SUCCEEDED\n            self.get_logger().info('Navigation SUCCEEDED!')\n        elif status == 5:  # CANCELED\n            self.get_logger().warn('Navigation CANCELED.')\n        elif status == 6:  # ABORTED\n            self.get_logger().error('Navigation ABORTED (could not reach goal).')\n\n        # Shutdown after reaching goal\n        rclpy.shutdown()\n\n\ndef main():\n    rclpy.init()\n    node = Nav2GoalSender()\n\n    # Example: navigate to position (3.0, 2.0) facing right (0 rad)\n    node.send_goal(x=3.0, y=2.0, yaw=0.0)\n\n    rclpy.spin(node)\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(e.h3,{id:"sending-a-sequence-of-waypoints",children:"Sending a Sequence of Waypoints"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"# multi_waypoint_nav.py\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.action import ActionClient\nfrom nav2_msgs.action import NavigateThroughPoses\nfrom geometry_msgs.msg import PoseStamped\nimport math\n\nclass WaypointNavigator(Node):\n    \"\"\"Navigate through a list of waypoints in sequence.\"\"\"\n\n    WAYPOINTS = [\n        (2.0, 0.0, 0.0),      # (x, y, yaw)\n        (2.0, 2.0, 1.5708),   # Turn left 90\xb0\n        (0.0, 2.0, 3.1416),   # Turn left 90\xb0 again\n        (0.0, 0.0, -1.5708),  # Return home\n    ]\n\n    def __init__(self):\n        super().__init__('waypoint_navigator')\n        self._client = ActionClient(\n            self,\n            NavigateThroughPoses,\n            'navigate_through_poses'\n        )\n\n    def navigate(self):\n        self._client.wait_for_server()\n\n        goal_msg = NavigateThroughPoses.Goal()\n        for x, y, yaw in self.WAYPOINTS:\n            pose = PoseStamped()\n            pose.header.frame_id = 'map'\n            pose.header.stamp = self.get_clock().now().to_msg()\n            pose.pose.position.x = x\n            pose.pose.position.y = y\n            q_z = math.sin(yaw / 2.0)\n            q_w = math.cos(yaw / 2.0)\n            pose.pose.orientation.z = q_z\n            pose.pose.orientation.w = q_w\n            goal_msg.poses.append(pose)\n\n        self.get_logger().info(\n            f'Navigating through {len(self.WAYPOINTS)} waypoints...'\n        )\n        future = self._client.send_goal_async(\n            goal_msg,\n            feedback_callback=self.feedback_cb\n        )\n        future.add_done_callback(self.goal_accepted_cb)\n\n    def feedback_cb(self, feedback_msg):\n        fb = feedback_msg.feedback\n        self.get_logger().info(\n            f'Waypoints remaining: {fb.number_of_poses_remaining}'\n        )\n\n    def goal_accepted_cb(self, future):\n        handle = future.result()\n        if handle.accepted:\n            handle.get_result_async().add_done_callback(self.done_cb)\n\n    def done_cb(self, future):\n        self.get_logger().info('Waypoint tour complete!')\n        rclpy.shutdown()\n\ndef main():\n    rclpy.init()\n    node = WaypointNavigator()\n    node.navigate()\n    rclpy.spin(node)\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"48-complete-nav2-configuration-file",children:"4.8 Complete Nav2 Configuration File"}),"\n",(0,t.jsxs)(e.p,{children:["A production-ready ",(0,t.jsx)(e.code,{children:"nav2_params.yaml"})," for a humanoid robot:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:'# nav2_params.yaml \u2014 complete configuration for humanoid robot navigation\n\nbt_navigator:\n  ros__parameters:\n    global_frame: map\n    robot_base_frame: base_link\n    odom_topic: /odometry/filtered   # From VSLAM / EKF\n    bt_loop_duration: 10             # ms\n    default_server_timeout: 20\n    # Default behaviour tree (can be overridden per goal)\n    default_nav_to_pose_bt_xml: ""   # Empty = use built-in default\n    navigators: [\'navigate_to_pose\', \'navigate_through_poses\']\n    navigate_to_pose:\n      plugin: "nav2_bt_navigator/NavigateToPoseNavigator"\n    navigate_through_poses:\n      plugin: "nav2_bt_navigator/NavigateThroughPosesNavigator"\n\nplanner_server:\n  ros__parameters:\n    planner_plugins: ["GridBased"]\n    GridBased:\n      plugin: "nav2_smac_planner/SmacPlannerHybrid"\n      tolerance: 0.25\n      minimum_turning_radius: 0.20\n      allow_unknown: true\n      max_iterations: 1000000\n      motion_model_for_search: "REEDS_SHEPP"\n\ncontroller_server:\n  ros__parameters:\n    controller_frequency: 20.0\n    min_x_velocity_threshold: 0.001\n    min_y_velocity_threshold: 0.5\n    min_theta_velocity_threshold: 0.001\n    failure_tolerance: 0.3\n    controller_plugins: ["FollowPath"]\n    FollowPath:\n      plugin: "dwb_core::DWBLocalPlanner"\n      debug_trajectory_details: True\n      min_vel_x: -0.10\n      max_vel_x: 0.50\n      min_vel_y: -0.20\n      max_vel_y: 0.20\n      max_vel_theta: 1.0\n      acc_lim_x: 0.5\n      acc_lim_theta: 2.5\n      sim_time: 1.7\n      xy_goal_tolerance: 0.25\n      yaw_goal_tolerance: 0.25\n      critics: ["RotateToGoal", "Oscillation", "BaseObstacle",\n                "GoalAlign", "PathAlign", "PathDist", "GoalDist"]\n      PathAlign.scale: 32.0\n      GoalAlign.scale: 24.0\n      PathDist.scale: 32.0\n      GoalDist.scale: 24.0\n      RotateToGoal.scale: 32.0\n\nrecoveries_server:\n  ros__parameters:\n    recovery_plugins: ["spin", "backup", "wait"]\n    spin:\n      plugin: "nav2_recoveries/Spin"\n    backup:\n      plugin: "nav2_recoveries/BackUp"\n    wait:\n      plugin: "nav2_recoveries/Wait"\n    spin_dist: 1.57          # Radians to spin during recovery\n    backup_dist: 0.30        # Metres to back up during recovery\n    backup_speed: 0.05       # Metres/sec backup speed\n    global_frame: odom\n    robot_base_frame: base_link\n    simulate_ahead_time: 2.0\n\nmap_server:\n  ros__parameters:\n    yaml_filename: "/maps/building_map.yaml"\n\namcl:\n  ros__parameters:\n    use_sim_time: False\n    # AMCL is for pre-built maps; swap with VSLAM for unknown environments\n    alpha1: 0.2\n    alpha2: 0.2\n    alpha3: 0.2\n    alpha4: 0.2\n    alpha5: 0.2\n    base_frame_id: base_footprint\n    beam_skip_distance: 0.5\n    global_frame_id: map\n    laser_model_type: likelihood_field\n    max_particles: 2000\n    min_particles: 500\n    odom_frame_id: odom\n    set_initial_pose: true\n    initial_pose:\n      x: 0.0\n      y: 0.0\n      z: 0.0\n      yaw: 0.0\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"49-launching-the-full-navigation-stack",children:"4.9 Launching the Full Navigation Stack"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"# launch/nav2_humanoid.launch.py\nimport os\nfrom ament_index_python.packages import get_package_share_directory\nfrom launch import LaunchDescription\nfrom launch.actions import IncludeLaunchDescription, DeclareLaunchArgument\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import LaunchConfiguration\nfrom launch_ros.actions import Node\n\ndef generate_launch_description():\n    nav2_bringup_dir = get_package_share_directory('nav2_bringup')\n    my_pkg_dir = get_package_share_directory('my_robot_pkg')\n\n    params_file = os.path.join(my_pkg_dir, 'config', 'nav2_params.yaml')\n    map_file = os.path.join(my_pkg_dir, 'maps', 'building_map.yaml')\n\n    return LaunchDescription([\n\n        # 1. cuVSLAM for localisation\n        IncludeLaunchDescription(\n            PythonLaunchDescriptionSource(\n                os.path.join(\n                    get_package_share_directory('isaac_ros_visual_slam'),\n                    'launch', 'isaac_ros_visual_slam_realsense.launch.py'\n                )\n            ),\n        ),\n\n        # 2. Nvblox for 3D mapping \u2192 2D costmap\n        Node(\n            package='nvblox_ros',\n            executable='nvblox_node',\n            name='nvblox',\n            output='screen',\n        ),\n\n        # 3. Nav2 bringup (all servers)\n        IncludeLaunchDescription(\n            PythonLaunchDescriptionSource(\n                os.path.join(nav2_bringup_dir, 'launch', 'bringup_launch.py')\n            ),\n            launch_arguments={\n                'map': map_file,\n                'params_file': params_file,\n                'use_sim_time': 'false',\n            }.items(),\n        ),\n\n        # 4. Twist \u2192 Gait bridge\n        Node(\n            package='my_robot_pkg',\n            executable='twist_to_gait',\n            name='twist_to_gait_bridge',\n            output='screen',\n        ),\n\n        # 5. RViz2 for visualisation\n        Node(\n            package='rviz2',\n            executable='rviz2',\n            name='rviz2',\n            arguments=[\n                '-d', os.path.join(my_pkg_dir, 'config', 'nav2.rviz')\n            ],\n        ),\n    ])\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"410-chapter-summary",children:"4.10 Chapter Summary"}),"\n",(0,t.jsx)(e.p,{children:"This chapter completed the deployment side of the Module 3 pipeline:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Nav2 architecture"}),": BT Navigator orchestrates the Planner Server, Controller Server, and Recoveries Server as lifecycle nodes."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Costmaps"})," translate sensor data into 2D grids of traversal costs. The global costmap covers the whole environment; the local costmap is a fast-updating rolling window around the robot. Configure the ",(0,t.jsx)(e.strong,{children:"footprint"})," carefully for humanoid dimensions."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Global planners"}),": NavFn (A*/Dijkstra, fast, simple) vs Smac Hybrid A* (smooth, kinematically feasible). Use Smac for narrow corridors and humanoids with turning constraints."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Local planners"}),": DWB (trajectory sampling + critics) provides flexible, tunable local control. Configure ",(0,t.jsx)(e.code,{children:"min_vel_y"}),"/",(0,t.jsx)(e.code,{children:"max_vel_y"})," to enable side-stepping for humanoids."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Humanoid-specific challenges"}),": quasi-holonomic motion, dynamic footprint, Twist \u2192 gait command translation, and eventually footstep planning for rough terrain."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Action API"}),": Navigation goals are sent via the ",(0,t.jsx)(e.code,{children:"NavigateToPose"})," and ",(0,t.jsx)(e.code,{children:"NavigateThroughPoses"})," ROS 2 action servers. Python action clients with feedback callbacks give full observability."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Full integration"}),": cuVSLAM \u2192 Nvblox \u2192 Nav2 \u2192 Twist-to-Gait bridge constitutes the complete autonomous navigation pipeline for an Isaac ROS-powered humanoid."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"module-3-summary",children:"Module 3 Summary"}),"\n",(0,t.jsx)(e.p,{children:"You have completed Module 3: The AI-Robot Brain (NVIDIA Isaac). Across four chapters you have:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Understood the Omniverse platform, USD scene format, and photorealistic rendering as the foundation for closing the sim-to-real gap"}),"\n",(0,t.jsx)(e.li,{children:"Built a complete synthetic data generation pipeline with domain randomisation, ground-truth annotators, and COCO export using Isaac Sim Replicator"}),"\n",(0,t.jsx)(e.li,{children:"Deployed GPU-accelerated cuVSLAM on Jetson Orin for real-time 6-DoF localisation and feature mapping"}),"\n",(0,t.jsx)(e.li,{children:"Configured and launched the Nav2 navigation stack for bipedal humanoid robots, including costmaps, global/local planners, and recovery behaviours"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"In Module 4 you will study Vision-Language-Action (VLA) models \u2014 the next frontier where end-to-end neural networks directly predict robot actions from images and natural language instructions, replacing the modular pipeline you have built in this module."}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"review-questions",children:"Review Questions"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:'Draw the Nav2 data flow for the command "navigate to the coffee machine": starting at the Python action client call, trace every component, message type, and topic until the gait controller receives a velocity command.'}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"Explain the difference between a global planner and a local planner. Could you use only a global planner without a local planner? What would go wrong if a person stepped into the robot's planned path?"}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"A roboticist configures the inflation radius to be exactly equal to the robot's inscribed radius. What dangerous scenario might this cause in a narrow corridor? What value should the inflation radius be relative to the robot's footprint?"}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"Your humanoid robot is tasked with navigating through a crowd. The DWB controller keeps oscillating back and forth instead of making progress. Which DWB critic is responsible for penalising oscillation, and what parameter would you increase to make the robot commit to a direction more aggressively?"}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:["Design the full ",(0,t.jsx)(e.code,{children:"nav2_params.yaml"})," changes needed to make a humanoid robot navigate significantly more conservatively \u2014 slower, with wider clearance from obstacles, and more willing to take longer paths to avoid tight spaces. List every parameter you would change and its new value, with a one-line justification for each."]}),"\n"]}),"\n"]})]})}function u(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(h,{...n})}):h(n)}},20(n,e,a){a.d(e,{A:()=>m});var o=a(6540),t=a(8774);const i="container_dCV0",r="row_RaZg",l="personalizeBtn_aAG4",s="showOriginalBtn_xRLS",c="badge_sNej",d="personalizedContent_IU8L",p="loginPrompt_KXHJ",h="error_X2St";var u=a(4848);function m(){const[n,e]=(0,o.useState)(!1),[a,m]=(0,o.useState)(null),[g,_]=(0,o.useState)("idle"),[f,v]=(0,o.useState)(""),[b,y]=(0,o.useState)("");(0,o.useEffect)(()=>{e(!0);const n=localStorage.getItem("auth_user");if(n)try{const e=JSON.parse(n);m(e.profile||null)}catch{}},[]);const x=(0,o.useCallback)(async()=>{if(!a)return;_("loading");const n=document.querySelector("article"),e=n?n.innerText:document.body.innerText,o="undefined"!=typeof window&&window.CHATBOT_API_URL?window.CHATBOT_API_URL:"http://localhost:8000";try{const n=await fetch(`${o}/personalize`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({content:e,experience_level:a.programmingExp||"Beginner",has_gpu:"Yes"===a.hasGPU,ros_experience:a.rosExperience||"none",learning_style:a.learningStyle||"Reading"})});if(!n.ok)throw new Error(`Server error ${n.status}`);const t=await n.json();v(t.personalized_content),_("done")}catch(t){y(t.message),_("error")}},[a]),j=(0,o.useCallback)(()=>{_("idle"),v(""),y("")},[]);return n?a?(0,u.jsxs)("div",{className:i,children:["idle"===g&&(0,u.jsx)("button",{className:l,onClick:x,children:"\u2728 Personalize for Me"}),"loading"===g&&(0,u.jsx)("button",{className:l,disabled:!0,children:"\u23f3 Personalizing\u2026"}),"error"===g&&(0,u.jsxs)("div",{className:r,children:[(0,u.jsx)("button",{className:l,onClick:x,children:"\u2728 Personalize for Me"}),(0,u.jsxs)("span",{className:h,children:["Failed: ",b]})]}),"done"===g&&(0,u.jsxs)("div",{children:[(0,u.jsxs)("div",{className:r,children:[(0,u.jsxs)("span",{className:c,children:["\u2728 Personalized for ",a.programmingExp," \xb7 ",a.learningStyle," learner"]}),(0,u.jsx)("button",{className:s,onClick:j,children:"\ud83d\udcc4 Show Original"})]}),(0,u.jsx)("div",{className:d,children:f})]})]}):(0,u.jsx)("div",{className:i,children:(0,u.jsxs)("span",{className:p,children:["\u2728"," ",(0,u.jsx)(t.A,{to:"/signin",children:"Sign in"})," ","to get content personalised to your experience level."]})}):null}},7132(n,e,a){a.d(e,{A:()=>p});var o=a(6540);const t="container_sRRF",i="row_Wfea",r="translateBtn_zwOG",l="showOriginalBtn__IG_",s="translatedContent_uGS7",c="error_H8Lp";var d=a(4848);function p(){const[n,e]=(0,o.useState)("idle"),[a,p]=(0,o.useState)(""),[h,u]=(0,o.useState)(""),m=(0,o.useCallback)(async()=>{e("loading");const n=document.querySelector("article"),a=n?n.innerText:document.body.innerText,o="undefined"!=typeof window&&window.CHATBOT_API_URL?window.CHATBOT_API_URL:"http://localhost:8000";try{const n=await fetch(`${o}/translate`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({text:a,target_language:"urdu"})});if(!n.ok)throw new Error(`Server error ${n.status}`);const t=await n.json();p(t.translated_text),e("translated")}catch(t){u(t.message),e("error")}},[]),g=(0,o.useCallback)(()=>{e("idle"),p(""),u("")},[]);return(0,d.jsxs)("div",{className:t,children:[("idle"===n||"error"===n)&&(0,d.jsxs)("div",{className:i,children:[(0,d.jsx)("button",{className:r,onClick:m,children:"\ud83c\udf10 Translate to Urdu"}),"error"===n&&(0,d.jsxs)("span",{className:c,children:["Translation failed: ",h]})]}),"loading"===n&&(0,d.jsx)("button",{className:r,disabled:!0,children:"\u23f3 Translating\u2026"}),"translated"===n&&(0,d.jsxs)("div",{children:[(0,d.jsx)("button",{className:l,onClick:g,children:"\ud83d\udcd6 Show Original English"}),(0,d.jsx)("div",{className:s,dir:"rtl",lang:"ur",children:a})]})]})}},8453(n,e,a){a.d(e,{R:()=>r,x:()=>l});var o=a(6540);const t={},i=o.createContext(t);function r(n){const e=o.useContext(i);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:r(n.components),o.createElement(i.Provider,{value:e},n.children)}}}]);