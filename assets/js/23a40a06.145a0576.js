"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[7602],{6527(e,n,i){i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module3-isaac/chapter1","title":"Chapter 1: NVIDIA Isaac Sim Overview","description":"Learning Objectives","source":"@site/docs/module3-isaac/chapter1.mdx","sourceDirName":"module3-isaac","slug":"/module3-isaac/chapter1","permalink":"/Hackathon-One-Physical-AI-Humanoid-Robotics-Course-/docs/module3-isaac/chapter1","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module3-isaac/chapter1.mdx","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Chapter 1: NVIDIA Isaac Sim Overview","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Real-Time Rendering","permalink":"/Hackathon-One-Physical-AI-Humanoid-Robotics-Course-/docs/module2-simulation/chapter3"},"next":{"title":"Chapter 2: Synthetic Data Generation","permalink":"/Hackathon-One-Physical-AI-Humanoid-Robotics-Course-/docs/module3-isaac/chapter2"}}');var r=i(4848),t=i(8453);const a={title:"Chapter 1: NVIDIA Isaac Sim Overview",sidebar_position:1},o="Chapter 1: NVIDIA Isaac Sim Overview",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"1.1 The Simulation Imperative",id:"11-the-simulation-imperative",level:2},{value:"1.2 The NVIDIA Omniverse Platform",id:"12-the-nvidia-omniverse-platform",level:2},{value:"What Is Omniverse?",id:"what-is-omniverse",level:3},{value:"Omniverse Kit",id:"omniverse-kit",level:3},{value:"The RTX Renderer",id:"the-rtx-renderer",level:3},{value:"1.3 Universal Scene Description (USD)",id:"13-universal-scene-description-usd",level:2},{value:"Why USD?",id:"why-usd",level:3},{value:"USD Core Concepts",id:"usd-core-concepts",level:3},{value:"USD Layers: Non-Destructive Overrides",id:"usd-layers-non-destructive-overrides",level:3},{value:"Converting URDF to USD",id:"converting-urdf-to-usd",level:3},{value:"1.4 Hardware Requirements",id:"14-hardware-requirements",level:2},{value:"Minimum vs Recommended Hardware",id:"minimum-vs-recommended-hardware",level:3},{value:"Cloud Deployment",id:"cloud-deployment",level:3},{value:"1.5 The Isaac Ecosystem: Sim, Lab, and ROS",id:"15-the-isaac-ecosystem-sim-lab-and-ros",level:2},{value:"When to Use Each",id:"when-to-use-each",level:3},{value:"1.6 Setting Up Isaac Sim",id:"16-setting-up-isaac-sim",level:2},{value:"Installation via Omniverse Launcher",id:"installation-via-omniverse-launcher",level:3},{value:"First Launch and the Python Console",id:"first-launch-and-the-python-console",level:3},{value:"1.7 Loading a Robot and Running Physics",id:"17-loading-a-robot-and-running-physics",level:2},{value:"1.8 Isaac Sim&#39;s Physics Engine: PhysX",id:"18-isaac-sims-physics-engine-physx",level:2},{value:"Articulation",id:"articulation",level:3},{value:"Contact Sensors",id:"contact-sensors",level:3},{value:"1.9 The ROS 2 Bridge",id:"19-the-ros-2-bridge",level:2},{value:"1.10 Chapter Summary",id:"110-chapter-summary",level:2},{value:"Review Questions",id:"review-questions",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"chapter-1-nvidia-isaac-sim-overview",children:"Chapter 1: NVIDIA Isaac Sim Overview"})}),"\n",(0,r.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,r.jsx)(n.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Describe the NVIDIA Omniverse platform and explain how Isaac Sim fits within it"}),"\n",(0,r.jsx)(n.li,{children:"Explain the Universal Scene Description (USD) format and its advantages over legacy robot description formats"}),"\n",(0,r.jsx)(n.li,{children:"Identify the hardware requirements for running Isaac Sim and understand why an RTX GPU is mandatory"}),"\n",(0,r.jsx)(n.li,{children:"Distinguish between Isaac Sim, Isaac Lab, and Isaac ROS and choose the right tool for a given task"}),"\n",(0,r.jsx)(n.li,{children:"Launch Isaac Sim, load a robot, and run a basic Python simulation script using the Omniverse Kit SDK"}),"\n",(0,r.jsx)(n.li,{children:"Explain how photorealistic rendering improves the realism of training data and reduces the sim-to-real gap"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"11-the-simulation-imperative",children:"1.1 The Simulation Imperative"}),"\n",(0,r.jsx)(n.p,{children:"Training and testing AI-powered robots in the real world is expensive, slow, and dangerous. A humanoid robot that falls during a poorly tuned gait experiment can destroy $150,000 of hardware and injure nearby people. A self-driving car that misidentifies a stop sign during real-world testing has catastrophic consequences."}),"\n",(0,r.jsxs)(n.p,{children:["Simulation solves this problem by providing a ",(0,r.jsx)(n.strong,{children:"safe, fast, infinitely resettable"})," environment. But not all simulators are equal. Classic robot simulators like Gazebo and PyBullet prioritise physics speed over visual fidelity, producing synthetic images that look nothing like the real world. When a neural network trained on these images is deployed on a real robot \u2014 a problem called the ",(0,r.jsx)(n.strong,{children:"sim-to-real gap"})," \u2014 it often fails immediately."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"NVIDIA Isaac Sim"})," takes a radically different approach. Built on the NVIDIA Omniverse platform with ray-traced photorealistic rendering, it produces images that are nearly indistinguishable from real camera footage. This dramatically reduces the sim-to-real gap and enables AI models to be trained almost entirely in simulation."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"12-the-nvidia-omniverse-platform",children:"1.2 The NVIDIA Omniverse Platform"}),"\n",(0,r.jsxs)(n.p,{children:["Isaac Sim is not a standalone application \u2014 it is one application built on the ",(0,r.jsx)(n.strong,{children:"NVIDIA Omniverse"})," platform. Understanding Omniverse is prerequisite to understanding Isaac Sim."]}),"\n",(0,r.jsx)(n.h3,{id:"what-is-omniverse",children:"What Is Omniverse?"}),"\n",(0,r.jsx)(n.p,{children:"Omniverse is NVIDIA's platform for building and connecting 3D simulation, design, and collaboration tools. It consists of:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        Omniverse Platform                       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Omniverse Kit   \u2502   USD (Scene Format) \u2502   RTX Renderer        \u2502\n\u2502  (App Framework) \u2502   (Data Interchange) \u2502   (PhysX + Ray Trace) \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502              Omniverse Nucleus (Asset & Scene Server)           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502        Built-on-Omniverse Applications                          \u2502\n\u2502  Isaac Sim \u2502 Isaac Lab \u2502 Omniverse Farm \u2502 USD Composer \u2502 Drive Sim\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,r.jsx)(n.h3,{id:"omniverse-kit",children:"Omniverse Kit"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Omniverse Kit"})," is the SDK used to build Omniverse applications. It provides:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"A Python-extensible application framework"}),"\n",(0,r.jsx)(n.li,{children:"Real-time 3D viewport with RTX rendering"}),"\n",(0,r.jsx)(n.li,{children:"Plugin architecture for physics engines, AI tools, and ROS bridges"}),"\n",(0,r.jsxs)(n.li,{children:["A built-in Python interpreter (",(0,r.jsx)(n.code,{children:"omni.kit"}),") accessible via scripting console"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Every Isaac Sim Python API call goes through Omniverse Kit extensions."}),"\n",(0,r.jsx)(n.h3,{id:"the-rtx-renderer",children:"The RTX Renderer"}),"\n",(0,r.jsxs)(n.p,{children:["The rendering engine in Omniverse uses NVIDIA's ",(0,r.jsx)(n.strong,{children:"RTX"})," (Ray Tracing) technology to simulate light physically accurately:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Ray tracing"}),": models individual photons bouncing off surfaces"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Path tracing"}),": Monte Carlo sampling of full light paths for ground-truth quality"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Real-time RTX"}),": denoised ray tracing at interactive frame rates"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This matters for robotics AI because perception models trained on ray-traced images encounter lighting, reflections, and shadows that match the real world \u2014 the core reason Isaac Sim produces better training data than rasterised simulators."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"13-universal-scene-description-usd",children:"1.3 Universal Scene Description (USD)"}),"\n",(0,r.jsxs)(n.p,{children:["Every scene, robot, and asset in Isaac Sim is represented in ",(0,r.jsx)(n.strong,{children:"USD"})," (Universal Scene Description), a format developed by Pixar Animation Studios and now maintained as an open standard."]}),"\n",(0,r.jsx)(n.h3,{id:"why-usd",children:"Why USD?"}),"\n",(0,r.jsxs)(n.p,{children:["Before USD, every 3D application had its own proprietary format: Maya had ",(0,r.jsx)(n.code,{children:".mb"}),", Blender had ",(0,r.jsx)(n.code,{children:".blend"}),", ROS had URDF. Exchanging assets between tools required error-prone manual conversion. USD solves this with a single, composable, non-destructive format that all tools can read and write."]}),"\n",(0,r.jsx)(n.h3,{id:"usd-core-concepts",children:"USD Core Concepts"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'USD Stage (the scene)\n  \u2514\u2500\u2500 Prim (every object is a "prim")\n        \u251c\u2500\u2500 Xform  (transform: position, rotation, scale)\n        \u251c\u2500\u2500 Mesh   (geometry: vertices, faces, UVs)\n        \u251c\u2500\u2500 Material (PBR shader inputs)\n        \u251c\u2500\u2500 PhysicsRigidBodyAPI  (physics properties)\n        \u251c\u2500\u2500 PhysicsCollisionAPI  (collision shape)\n        \u2514\u2500\u2500 RobotAPI / JointAPI  (articulation properties)\n'})}),"\n",(0,r.jsx)(n.p,{children:"Key USD concepts for roboticists:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Concept"}),(0,r.jsx)(n.th,{children:"Meaning"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Stage"})}),(0,r.jsxs)(n.td,{children:["The entire scene (like a ",(0,r.jsx)(n.code,{children:".blend"})," file or a ROS world)"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Prim"})}),(0,r.jsx)(n.td,{children:"Any object in the scene (mesh, light, camera, joint)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Layer"})}),(0,r.jsx)(n.td,{children:"A file that overrides properties of a base USD stage"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Composition"})}),(0,r.jsx)(n.td,{children:"Combining multiple USD files \u2014 e.g. robot URDF + environment USD"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Schema"})}),(0,r.jsxs)(n.td,{children:["A typed API applied to a prim \u2014 e.g. ",(0,r.jsx)(n.code,{children:"PhysicsRigidBodyAPI"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Payload"})}),(0,r.jsx)(n.td,{children:"Lazy-loading of heavy assets (loads on demand, not at startup)"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"usd-layers-non-destructive-overrides",children:"USD Layers: Non-Destructive Overrides"}),"\n",(0,r.jsxs)(n.p,{children:["USD's ",(0,r.jsx)(n.strong,{children:"layering"})," system allows you to modify a scene without changing its base files. For example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"base_robot.usd          \u2190 Manufacturer's robot model (read-only)\n    \u2514\u2500\u2500 my_experiment.usd  \u2190 Your overrides: new sensors, materials, poses\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This is analogous to Git branches: the base is untouched; you compose variations on top. This is how Isaac Sim's ",(0,r.jsx)(n.strong,{children:"domain randomisation"})," works \u2014 it writes property overrides into a temporary layer."]}),"\n",(0,r.jsx)(n.h3,{id:"converting-urdf-to-usd",children:"Converting URDF to USD"}),"\n",(0,r.jsx)(n.p,{children:"Isaac Sim can import URDF files and convert them to USD:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# In Isaac Sim Python console or script\nfrom omni.isaac.urdf import _urdf\n\nurdf_interface = _urdf.acquire_urdf_interface()\nconfig = _urdf.ImportConfig()\nconfig.merge_fixed_joints = False\nconfig.fix_base = False\nconfig.import_inertia_tensor = True\nconfig.distance_scale = 1.0\nconfig.density = 0.0\nconfig.default_drive_type = _urdf.UrdfJointTargetType.JOINT_DRIVE_VELOCITY\nconfig.default_drive_strength = 1047.197551\nconfig.default_position_drive_damping = 52.35988\n\nresult, prim_path = omni.kit.commands.execute(\n    "URDFParseAndImportFile",\n    urdf_path="/path/to/humanoid.urdf",\n    import_config=config,\n)\nprint(f"Robot imported at: {prim_path}")\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"14-hardware-requirements",children:"1.4 Hardware Requirements"}),"\n",(0,r.jsx)(n.p,{children:"Isaac Sim's RTX rendering places substantial demands on your GPU. These are not optional \u2014 they reflect genuine computational requirements of real-time path tracing."}),"\n",(0,r.jsx)(n.h3,{id:"minimum-vs-recommended-hardware",children:"Minimum vs Recommended Hardware"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Component"}),(0,r.jsx)(n.th,{children:"Minimum"}),(0,r.jsx)(n.th,{children:"Recommended"}),(0,r.jsx)(n.th,{children:"Notes"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"GPU"})}),(0,r.jsx)(n.td,{children:"RTX 3070 8 GB"}),(0,r.jsx)(n.td,{children:"RTX 4090 24 GB"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.strong,{children:"Must be RTX"})," \u2014 no GTX, no AMD for full features"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"CPU"})}),(0,r.jsx)(n.td,{children:"Intel i7 / Ryzen 7"}),(0,r.jsx)(n.td,{children:"Intel i9 / Ryzen 9"}),(0,r.jsx)(n.td,{children:"Multi-core for physics simulation"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"RAM"})}),(0,r.jsx)(n.td,{children:"32 GB"}),(0,r.jsx)(n.td,{children:"64 GB"}),(0,r.jsx)(n.td,{children:"Large scenes + Python runtime + ML models"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"VRAM"})}),(0,r.jsx)(n.td,{children:"8 GB"}),(0,r.jsx)(n.td,{children:"24 GB"}),(0,r.jsx)(n.td,{children:"Complex scenes with many assets exhaust VRAM"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Storage"})}),(0,r.jsx)(n.td,{children:"50 GB SSD"}),(0,r.jsx)(n.td,{children:"500 GB NVMe SSD"}),(0,r.jsx)(n.td,{children:"Isaac Sim install + nucleus assets"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"OS"})}),(0,r.jsx)(n.td,{children:"Ubuntu 20.04 / 22.04"}),(0,r.jsx)(n.td,{children:"Ubuntu 22.04"}),(0,r.jsx)(n.td,{children:"Windows 10/11 supported but Linux preferred"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"cloud-deployment",children:"Cloud Deployment"}),"\n",(0,r.jsxs)(n.p,{children:["For teams without high-end GPUs, NVIDIA offers ",(0,r.jsx)(n.strong,{children:"Isaac Sim on AWS"})," through the NGC (NVIDIA GPU Cloud) catalog. You can rent an ",(0,r.jsx)(n.code,{children:"g4dn.xlarge"})," (T4) or ",(0,r.jsx)(n.code,{children:"p3.2xlarge"})," (V100) instance and run Isaac Sim headlessly, streaming the viewport to your local machine."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Run Isaac Sim headlessly (no display required)\n./runheadless.native.sh --/app/window/width=1280 --/app/window/height=720\n"})}),"\n",(0,r.jsx)(n.p,{children:"Headless mode is essential for large-scale synthetic data generation on cloud GPU farms."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"15-the-isaac-ecosystem-sim-lab-and-ros",children:"1.5 The Isaac Ecosystem: Sim, Lab, and ROS"}),"\n",(0,r.jsx)(n.p,{children:"NVIDIA's Isaac brand encompasses three distinct but complementary products. Students often confuse them."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  NVIDIA Isaac Ecosystem                                             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Isaac Sim       \u2502  Isaac Lab           \u2502  Isaac ROS                \u2502\n\u2502                  \u2502                      \u2502                           \u2502\n\u2502  Full simulation \u2502  Reinforcement       \u2502  Hardware-accelerated     \u2502\n\u2502  environment     \u2502  learning framework  \u2502  ROS 2 packages for       \u2502\n\u2502  \u2022 Photorealistic\u2502  \u2022 Built on Isaac Sim\u2502  deployment on real       \u2502\n\u2502    rendering     \u2502  \u2022 GPU-parallelised  \u2502  robots                   \u2502\n\u2502  \u2022 Synthetic data\u2502    RL training       \u2502  \u2022 cuVSLAM                \u2502\n\u2502    generation    \u2502  \u2022 Imitation learning\u2502  \u2022 Nvblox 3D mapping      \u2502\n\u2502  \u2022 Physics (PhysX\u2502  \u2022 Task design API   \u2502  \u2022 AprilTag detection     \u2502\n\u2502    + Flex)       \u2502  \u2022 4096+ envs        \u2502  \u2022 Stereo depth           \u2502\n\u2502  \u2022 ROS 2 bridge  \u2502    simultaneously    \u2502  \u2022 Runs on Jetson Orin    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,r.jsx)(n.h3,{id:"when-to-use-each",children:"When to Use Each"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Isaac Sim"}),": Develop and test robot behaviours; generate synthetic training data; test navigation and manipulation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Isaac Lab"}),": Train reinforcement learning policies at scale; train locomotion controllers for humanoids"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Isaac ROS"}),": Deploy pre-trained models on a real robot with Jetson hardware acceleration"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"A typical development pipeline uses all three:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Train locomotion in ",(0,r.jsx)(n.strong,{children:"Isaac Lab"})," (millions of simulated steps in hours)"]}),"\n",(0,r.jsxs)(n.li,{children:["Test full-stack behaviour in ",(0,r.jsx)(n.strong,{children:"Isaac Sim"})," (photorealistic, with sensors)"]}),"\n",(0,r.jsxs)(n.li,{children:["Deploy on hardware using ",(0,r.jsx)(n.strong,{children:"Isaac ROS"})," (Jetson-accelerated inference)"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"16-setting-up-isaac-sim",children:"1.6 Setting Up Isaac Sim"}),"\n",(0,r.jsx)(n.h3,{id:"installation-via-omniverse-launcher",children:"Installation via Omniverse Launcher"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'# 1. Download the Omniverse Launcher from developer.nvidia.com/omniverse\n# 2. Install it:\nchmod +x omniverse-launcher-linux.AppImage\n./omniverse-launcher-linux.AppImage\n\n# 3. From the Launcher UI, install "Isaac Sim" (\u224815 GB download)\n# 4. Also install "Nucleus" local server for assets\n'})}),"\n",(0,r.jsx)(n.h3,{id:"first-launch-and-the-python-console",children:"First Launch and the Python Console"}),"\n",(0,r.jsxs)(n.p,{children:["After launch, Isaac Sim opens with a 3D viewport. The built-in ",(0,r.jsx)(n.strong,{children:"Script Editor"})," (Window \u2192 Script Editor) allows running Python scripts against the live simulation."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# Script Editor: Hello World \u2014 create a sphere in the scene\nimport omni.kit.commands\nimport omni\n\n# Create a sphere prim at the origin\nomni.kit.commands.execute(\n    'CreateMeshPrimWithDefaultXform',\n    prim_type='Sphere',\n)\n\n# Select it and move it up 1 metre\nfrom pprint import pprint\nstage = omni.usd.get_context().get_stage()\nsphere_prim = stage.GetPrimAtPath('/World/Sphere')\nxform = sphere_prim.GetAttribute('xformOp:translate')\nxform.Set((0.0, 0.0, 1.0))\n\nprint(\"Sphere created at (0, 0, 1)\")\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"17-loading-a-robot-and-running-physics",children:"1.7 Loading a Robot and Running Physics"}),"\n",(0,r.jsx)(n.p,{children:"Isaac Sim ships with pre-built robot USD assets for popular platforms (Franka, UR10, Carter, Spot, H1). Here is a complete Python script that loads a humanoid robot and runs a physics simulation:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# standalone_simulation.py\n# Run with: ./python.sh standalone_simulation.py\n\nimport carb\nfrom omni.isaac.kit import SimulationApp\n\n# Must create SimulationApp BEFORE importing any omni modules\nsimulation_app = SimulationApp({\n    "headless": False,          # Set True for server-side rendering\n    "width": 1280,\n    "height": 720,\n    "renderer": "RayTracedLighting",\n})\n\n# Now safe to import Isaac Sim modules\nimport omni.kit.commands\nfrom omni.isaac.core import World\nfrom omni.isaac.core.robots import Robot\nfrom omni.isaac.core.utils.stage import add_reference_to_stage\nfrom omni.isaac.core.utils.nucleus import get_assets_root_path\nimport numpy as np\n\n# \u2500\u2500 Scene Setup \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nworld = World(\n    stage_units_in_meters=1.0,\n    physics_dt=1.0 / 400.0,     # Physics runs at 400 Hz\n    rendering_dt=1.0 / 60.0,    # Renderer at 60 Hz\n)\n\n# Add a ground plane\nworld.scene.add_default_ground_plane()\n\n# \u2500\u2500 Load Robot Asset \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nassets_root = get_assets_root_path()\n# Unitree H1 humanoid (available in Isaac Sim asset library)\nrobot_asset_path = (\n    assets_root + "/Isaac/Robots/Unitree/H1/h1.usd"\n)\n\n# Add the robot USD to the stage\nadd_reference_to_stage(\n    usd_path=robot_asset_path,\n    prim_path="/World/H1"\n)\n\n# Wrap it in a Robot object for easy control\nrobot = world.scene.add(\n    Robot(\n        prim_path="/World/H1",\n        name="h1_robot",\n        position=np.array([0.0, 0.0, 1.05]),  # Spawn 1.05m above ground\n    )\n)\n\n# \u2500\u2500 Lighting \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nfrom omni.isaac.core.utils.prims import create_prim\n# Add a distant light (simulates sunlight)\nomni.kit.commands.execute(\n    "CreatePrim",\n    prim_path="/World/DistantLight",\n    prim_type="DistantLight",\n    attributes={\n        "inputs:intensity": 3000.0,\n        "inputs:angle": 0.53,\n        "xformOp:rotateXYZ": (315.0, 0.0, 0.0),\n    }\n)\n\n# \u2500\u2500 Simulation Loop \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nworld.reset()\n\nnum_dof = robot.num_dof\nprint(f"Robot has {num_dof} degrees of freedom.")\nprint(f"Joint names: {robot.dof_names}")\n\nstep = 0\nwhile simulation_app.is_running():\n    # Step the physics and renderer\n    world.step(render=True)\n\n    if world.is_playing():\n        # Read current joint positions\n        joint_positions = robot.get_joint_positions()\n\n        # Read base (root) position and orientation\n        base_pos, base_rot = robot.get_world_pose()\n\n        if step % 100 == 0:  # Print every 100 steps\n            print(f"Step {step}: base_z = {base_pos[2]:.3f} m")\n            print(f"  joint[0] = {joint_positions[0]:.4f} rad")\n\n        step += 1\n\n# Cleanup\nsimulation_app.close()\n'})}),"\n",(0,r.jsx)(n.p,{children:"Run it from the Isaac Sim Python environment:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"cd ~/.local/share/ov/pkg/isaac-sim-4.x.x/\n./python.sh /path/to/standalone_simulation.py\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"18-isaac-sims-physics-engine-physx",children:"1.8 Isaac Sim's Physics Engine: PhysX"}),"\n",(0,r.jsxs)(n.p,{children:["Isaac Sim uses NVIDIA's ",(0,r.jsx)(n.strong,{children:"PhysX"})," physics engine, which runs on the GPU for massively parallel simulation. Key features relevant to humanoid robotics:"]}),"\n",(0,r.jsx)(n.h3,{id:"articulation",children:"Articulation"}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.strong,{children:"PhysX Articulation"})," is the rigid body representation of a kinematic chain \u2014 exactly what a robot arm or humanoid body is. Articulations are more stable and faster than simulating each link as a separate rigid body."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from omni.isaac.core.articulations import Articulation\n\n# Get the robot as an articulation for direct joint control\narticulation = Articulation(prim_path="/World/H1")\nworld.scene.add(articulation)\nworld.reset()\n\n# Set joint position targets (PD controller)\narticulation.get_articulation_controller().apply_action(\n    ArticulationAction(\n        joint_positions=np.zeros(num_dof),    # Target: all joints at 0\n        joint_velocities=np.zeros(num_dof),\n        joint_efforts=None,                    # Let PD handle it\n    )\n)\n'})}),"\n",(0,r.jsx)(n.h3,{id:"contact-sensors",children:"Contact Sensors"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from omni.isaac.sensor import ContactSensor\n\n# Attach contact sensors to robot feet\nleft_foot_sensor = ContactSensor(\n    prim_path="/World/H1/left_ankle_roll_link/contact_sensor",\n    name="left_foot_contact",\n    min_threshold=0,\n    max_threshold=10000000,\n    radius=-1,  # -1 = use collision shape\n)\nworld.scene.add(left_foot_sensor)\n\n# In simulation loop:\ncontact_data = left_foot_sensor.get_current_frame()\nif contact_data["in_contact"]:\n    print(f"Left foot contact force: {contact_data[\'force\']}")\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"19-the-ros-2-bridge",children:"1.9 The ROS 2 Bridge"}),"\n",(0,r.jsx)(n.p,{children:"Isaac Sim can publish and subscribe to ROS 2 topics, making it a drop-in replacement for a real robot during software development."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# Enable the ROS 2 bridge extension\nimport omni.ext\nimport omni.graph.core as og\n\n# Action Graph for ROS 2 clock publisher\nog.Controller.edit(\n    {"graph_path": "/ROS2_Clock", "evaluator_name": "execution"},\n    {\n        og.Controller.Keys.CREATE_NODES: [\n            ("OnPlaybackTick", "omni.graph.action.OnPlaybackTick"),\n            ("ROS2Clock",      "omni.isaac.ros2_bridge.ROS2PublishClock"),\n        ],\n        og.Controller.Keys.CONNECT: [\n            ("OnPlaybackTick.outputs:tick", "ROS2Clock.inputs:execIn"),\n        ],\n    }\n)\n'})}),"\n",(0,r.jsx)(n.p,{children:"Once the bridge is active, you can verify the connection:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# In a terminal with ROS 2 sourced:\nros2 topic list\n# Should show:\n# /clock\n# /tf\n# /joint_states\n# /camera/image_raw   (if a camera sensor is configured)\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"110-chapter-summary",children:"1.10 Chapter Summary"}),"\n",(0,r.jsx)(n.p,{children:"In this chapter you established the conceptual and practical foundation for working with Isaac Sim:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Simulation necessity"}),": The sim-to-real gap is the central problem in robot AI training. Isaac Sim addresses it with RTX photorealistic rendering."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Omniverse platform"}),": Isaac Sim is built on Omniverse Kit, which provides the application framework, RTX renderer, and USD scene format."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"USD"}),": The Universal Scene Description format enables composable, non-destructive scene representation. Layers allow domain randomisation without modifying base assets."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Hardware requirements"}),": An RTX GPU with \u22658 GB VRAM is mandatory. Headless cloud deployment on AWS/GCP is a viable alternative."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Isaac ecosystem"}),": Isaac Sim (simulation), Isaac Lab (RL training), and Isaac ROS (deployment) are complementary tools covering the full robot AI pipeline."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Python scripting"}),": The ",(0,r.jsx)(n.code,{children:"SimulationApp"})," + ",(0,r.jsx)(n.code,{children:"World"})," + ",(0,r.jsx)(n.code,{children:"Robot"}),"/",(0,r.jsx)(n.code,{children:"Articulation"})," pattern is the foundation of all Isaac Sim Python scripts."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"ROS 2 bridge"}),": Isaac Sim publishes sensor data and subscribes to command topics, making it transparent to your ROS 2 software stack."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"review-questions",children:"Review Questions"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Explain the sim-to-real gap in your own words. Why does photorealistic rendering (ray tracing) help close this gap more than rasterised rendering?"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"What is a USD Layer, and how does it relate to domain randomisation? Draw a diagram showing the layer composition for a robot with three different material randomisations."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Your lab has a single workstation with an NVIDIA GTX 1080 Ti (8 GB VRAM, no RT cores). Can you run Isaac Sim on it? What are your alternatives?"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"What is the difference between Isaac Sim and Isaac Lab? If you wanted to train a walking controller for a bipedal robot using reinforcement learning on 4,096 parallel environments, which would you use?"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Sketch the data flow from a camera sensor in Isaac Sim to a PyTorch object detection model running in a separate Python process. List every technology at each step (USD prim \u2192 Isaac Sim extension \u2192 ROS 2 bridge \u2192 ROS 2 topic \u2192 subscriber node \u2192 tensor)."}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453(e,n,i){i.d(n,{R:()=>a,x:()=>o});var s=i(6540);const r={},t=s.createContext(r);function a(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);