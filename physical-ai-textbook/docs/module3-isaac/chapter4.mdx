---
title: "Chapter 4: Nav2 and Path Planning for Humanoids"
sidebar_position: 4
---

import TranslateButton from '@site/src/components/TranslateButton';

<TranslateButton />

# Chapter 4: Nav2 and Path Planning for Humanoid Robots

## Learning Objectives

By the end of this chapter, you will be able to:

- Describe the Nav2 stack architecture and the role of each component
- Explain global and local costmaps and configure them for a humanoid robot footprint
- Distinguish between global path planners (NavFn, Smac) and local trajectory planners (DWB, TEB)
- Identify the unique challenges of bipedal navigation compared to wheeled robots
- Integrate VSLAM odometry and Nvblox occupancy maps with the Nav2 stack
- Send navigation goals programmatically via the Nav2 action API in Python
- Configure recovery behaviours for stuck and lost scenarios

---

## 4.1 Navigation: The Full Problem

A navigating robot must solve three sub-problems simultaneously:

```
┌─────────────────────────────────────────────────────────────────┐
│  Navigation Problem                                             │
│                                                                 │
│  1. WHERE AM I?         → Localisation (VSLAM / AMCL / EKF)   │
│                                                                 │
│  2. WHAT'S AROUND ME?   → Mapping (Nvblox / costmap)          │
│                                                                 │
│  3. HOW DO I GET THERE? → Path planning + trajectory control   │
│        • Global planner: compute a path through free space     │
│        • Local planner: follow the path while avoiding         │
│          dynamic obstacles                                      │
│        • Controller: convert velocity commands to              │
│          actuator outputs                                       │
└─────────────────────────────────────────────────────────────────┘
```

**Nav2** (Navigation2) is the ROS 2 navigation stack that solves sub-problem 3. It is modular, plugin-based, and designed to work with any robot that can publish odometry and receive `Twist` velocity commands.

---

## 4.2 The Nav2 Architecture

Nav2 consists of several servers, each running as a lifecycle-managed ROS 2 node (recall the lifecycle from Chapter 1 of Module 1):

```
            ┌────────────────────────────────────────┐
            │        Navigation Goal (Action)         │
            │    /navigate_to_pose, /navigate_through │
            └────────────────┬───────────────────────┘
                             │
                             ▼
                    ┌─────────────────┐
                    │  BT Navigator   │     Behaviour Tree
                    │  (orchestrator) │     controls the navigation
                    └────────┬────────┘     state machine
                             │
              ┌──────────────┼──────────────┐
              ▼              ▼              ▼
    ┌──────────────┐ ┌──────────────┐ ┌──────────────┐
    │   Planner    │ │  Controller  │ │   Recoveries │
    │   Server     │ │   Server     │ │   Server     │
    │ (global path)│ │ (local traj) │ │ (stuck/lost) │
    └──────┬───────┘ └──────┬───────┘ └──────┬───────┘
           │                │                │
           ▼                ▼                ▼
   ┌─────────────────────────────────────────────────┐
   │              Costmap 2D                          │
   │  (global costmap)    (local costmap)             │
   │  Inflation layer     Obstacle layer              │
   │  Static map layer    Voxel layer (3D→2D)         │
   └─────────────────────────────────────────────────┘
           │                │
           ▼                ▼
     /map (OccGrid)   /scan or /depth
```

### The Behaviour Tree

Nav2's **Behaviour Tree (BT)** navigator orchestrates the planning, control, and recovery steps. It is a tree of conditional and action nodes that defines the high-level navigation policy:

```xml
<!-- Default nav2 behaviour tree (simplified) -->
<root main_tree_to_execute="MainTree">
  <BehaviorTree ID="MainTree">
    <RecoveryNode number_of_retries="6" name="NavigateWithReplanning">

      <!-- Main action: compute global path, then follow it -->
      <PipelineSequence name="NavigateWithReplanning">
        <RateController hz="1.0">
          <ComputePathToPose goal="{goal}" path="{path}" />
        </RateController>
        <FollowPath path="{path}" controller_id="FollowPath" />
      </PipelineSequence>

      <!-- Recovery: if stuck, try spinning, backing up, etc. -->
      <ReactiveFallback name="RecoveryFallback">
        <GoalUpdated/>
        <RoundRobin name="RecoveryActions">
          <Sequence name="ClearingActions">
            <ClearEntireCostmap server_name="local_costmap/clear_entirely_local_costmap"/>
            <ClearEntireCostmap server_name="global_costmap/clear_entirely_global_costmap"/>
          </Sequence>
          <Spin spin_dist="1.57" />
          <Wait wait_duration="5" />
          <BackUp backup_dist="0.30" backup_speed="0.05" />
        </RoundRobin>
      </ReactiveFallback>

    </RecoveryNode>
  </BehaviorTree>
</root>
```

---

## 4.3 Costmaps

A **costmap** is a 2D grid where each cell holds a cost value from 0 (free) to 254 (lethal obstacle). The planner searches this grid for a path from start to goal.

Nav2 uses two costmaps:

### Global Costmap

The global costmap covers the entire known environment. It is updated slowly (on the order of 0.5–1 Hz) and is used by the **global planner** to compute the initial path.

```
Cell values:
  0          = Free space (robot can traverse)
  1–252      = Inflation (penalty zone around obstacles)
  253        = Inscribed (inside robot footprint radius — forbidden)
  254        = Lethal (occupied by an obstacle)
  255        = Unknown (not yet observed)
```

### Local Costmap

The local costmap is a smaller window around the robot (e.g., 3×3 metres), updated at 10 Hz or faster. It is used by the **local planner** to track the global path while reacting to dynamic obstacles (people walking by, fallen objects).

### Costmap Configuration for a Humanoid

A wheeled robot's footprint is typically circular. A humanoid's footprint depends on its stance and can be modelled as a rectangle:

```yaml
# nav2_params.yaml — costmap section for a humanoid

global_costmap:
  global_costmap:
    ros__parameters:
      update_frequency: 0.5        # Hz — slow, uses static map
      publish_frequency: 1.0
      global_frame: map
      robot_base_frame: base_link
      resolution: 0.05             # 5 cm/cell

      # Humanoid footprint: 40cm wide, 30cm deep (conservative)
      footprint: >-
        [[-0.15, -0.20], [-0.15, 0.20],
         [0.15, 0.20], [0.15, -0.20]]

      plugins: ["static_layer", "inflation_layer"]

      static_layer:
        plugin: "nav2_costmap_2d::StaticLayer"
        map_subscribe_transient_local: True

      inflation_layer:
        plugin: "nav2_costmap_2d::InflationLayer"
        inflation_radius: 0.55     # Must be > robot radius (0.28m for humanoid)
        cost_scaling_factor: 3.0   # Exponential decay of costs

local_costmap:
  local_costmap:
    ros__parameters:
      update_frequency: 10.0       # Hz — fast, reacts to dynamic obstacles
      publish_frequency: 10.0
      global_frame: odom
      robot_base_frame: base_link
      rolling_window: true
      width: 3.5                   # Metres
      height: 3.5
      resolution: 0.05

      # Same footprint
      footprint: >-
        [[-0.15, -0.20], [-0.15, 0.20],
         [0.15, 0.20], [0.15, -0.20]]

      plugins: ["obstacle_layer", "inflation_layer"]

      obstacle_layer:
        plugin: "nav2_costmap_2d::ObstacleLayer"
        enabled: True
        observation_sources: scan
        scan:
          topic: /scan
          max_obstacle_height: 2.0
          clearing: True
          marking: True
          data_type: "LaserScan"
          raytrace_max_range: 5.0
          raytrace_min_range: 0.0
          obstacle_max_range: 4.5
          obstacle_min_range: 0.0

      inflation_layer:
        plugin: "nav2_costmap_2d::InflationLayer"
        inflation_radius: 0.55
        cost_scaling_factor: 3.0
```

---

## 4.4 Global Path Planners

The **global planner** computes an obstacle-free path from the robot's current position to the goal on the global costmap. Nav2 provides several plugin implementations:

### NavFn (Dijkstra / A*)

The original ROS global planner. Uses A* (or Dijkstra) to find the shortest path on the costmap grid.

```yaml
planner_server:
  ros__parameters:
    planner_plugins: ["GridBased"]
    GridBased:
      plugin: "nav2_navfn_planner/NavfnPlanner"
      tolerance: 0.5       # Acceptable goal distance error (metres)
      use_astar: true      # True = A*, False = Dijkstra
      allow_unknown: true  # Can plan through unknown cells
```

**Pros**: Fast, well-tested, simple. **Cons**: Only 8-connected (45° angle resolution), ignores kinematic constraints.

### Smac Planner (Hybrid A*)

The **Smac Planner** family is Nav2's modern alternative. It uses **Hybrid A*** — a search that respects the robot's turning radius and produces smooth, kinematically feasible paths.

```yaml
planner_server:
  ros__parameters:
    planner_plugins: ["GridBased"]
    GridBased:
      plugin: "nav2_smac_planner/SmacPlannerHybrid"
      downsample_costmap: false
      downsampling_factor: 1
      tolerance: 0.25
      allow_unknown: true
      max_iterations: 1000000

      # Kinematic constraints for a humanoid walking in 2D
      minimum_turning_radius: 0.2  # metres — humanoids turn ~in-place
      reverse_penalty: 2.0         # Penalise walking backwards
      change_penalty: 0.0
      non_straight_penalty: 1.2

      # Analytic expansion for faster goal connection
      analytic_expansion_ratio: 3.5
      analytic_expansion_max_length: 3.0

      # Lattice planner settings (for non-holonomic)
      motion_model_for_search: "REEDS_SHEPP"  # or "DUBIN" for forward-only
```

**Pros**: Smooth paths, respects turning radius, better for narrow corridors. **Cons**: Slower than NavFn (but usually still sub-second).

---

## 4.5 Local Trajectory Planners

The **local planner** (called the "controller" in Nav2) tracks the global path in real-time, adjusting for dynamic obstacles and robot dynamics.

### DWB (Dynamic Window Approach with Critics)

DWB simulates many possible velocity commands forward in time, evaluates each with a set of **critic functions**, and selects the command that scores best.

```
┌─────────────────────────────────────────────────┐
│  DWB Planning Cycle (10–20 Hz)                  │
│                                                 │
│  1. Sample velocity space (v, ω) pairs          │
│  2. Simulate trajectories for each sample       │
│  3. Score each with critics:                    │
│     • PathAlign:  is trajectory following path? │
│     • GoalAlign:  pointing toward goal?         │
│     • PathDist:   distance to global path       │
│     • GoalDist:   distance to goal              │
│     • Oscillation: penalise direction reversals │
│     • Obstacle:  penalty for nearness to walls  │
│  4. Select highest-scoring safe trajectory      │
│  5. Publish first velocity command from it      │
└─────────────────────────────────────────────────┘
```

```yaml
controller_server:
  ros__parameters:
    controller_plugins: ["FollowPath"]
    controller_frequency: 20.0    # Hz

    FollowPath:
      plugin: "dwb_core::DWBLocalPlanner"

      # Velocity limits — must match actual robot capabilities
      min_vel_x: -0.10            # Allow backing up slowly
      max_vel_x: 0.50             # Maximum forward speed (m/s)
      min_vel_y: 0.0              # Non-holonomic: no lateral movement
      max_vel_y: 0.0
      max_vel_theta: 1.0          # Maximum rotation speed (rad/s)
      min_speed_xy: 0.0
      max_speed_xy: 0.50

      # Acceleration limits — humanoid gait constraints
      acc_lim_x: 0.5              # m/s² — gentle acceleration
      acc_lim_y: 0.0
      acc_lim_theta: 2.5          # rad/s²
      decel_lim_x: -0.5

      # Trajectory simulation
      sim_time: 1.7               # Seconds to simulate forward
      sim_granularity: 0.025      # Metres between simulated points
      angular_sim_granularity: 0.025

      # Goal tolerance
      xy_goal_tolerance: 0.25     # Metres
      yaw_goal_tolerance: 0.25    # Radians (~14°)

      # Critic weights
      critics: ["RotateToGoal", "Oscillation", "BaseObstacle",
                "GoalAlign", "PathAlign", "PathDist", "GoalDist"]
      BaseObstacle.scale: 0.02
      PathAlign.scale: 32.0
      PathAlign.forward_point_distance: 0.1
      GoalAlign.scale: 24.0
      GoalAlign.forward_point_distance: 0.1
      PathDist.scale: 32.0
      GoalDist.scale: 24.0
      RotateToGoal.scale: 32.0
      RotateToGoal.slowing_factor: 5.0
      RotateToGoal.lookahead_time: -1.0
```

### Regulated Pure Pursuit (RPP)

For holonomic robots or simpler scenarios, **Regulated Pure Pursuit** is a lightweight controller that follows the path by steering toward a lookahead point:

```yaml
FollowPath:
  plugin: "nav2_regulated_pure_pursuit_controller::RegulatedPurePursuitController"
  desired_linear_vel: 0.4
  lookahead_dist: 0.6
  min_lookahead_dist: 0.3
  max_lookahead_dist: 0.9
  lookahead_time: 1.5
  rotate_to_heading_angular_vel: 1.0
  use_velocity_scaled_lookahead_dist: true
  min_approach_linear_velocity: 0.05
  max_allowed_time_to_collision_up_to_carrot: 1.0
  use_regulated_linear_velocity_scaling: true
  use_cost_regulated_linear_velocity_scaling: false
  regulated_linear_scaling_min_radius: 0.9
  regulated_linear_scaling_min_speed: 0.25
  use_rotate_to_heading: true    # Rotate in-place to face goal direction
  allow_reversing: false
  rotate_to_heading_min_angle: 0.785
  max_angular_accel: 2.0
  max_robot_pose_search_dist: 10.0
```

---

## 4.6 Humanoid-Specific Navigation Challenges

Wheeled robots and bipedal humanoids share much of the same navigation stack, but bipedal locomotion introduces unique considerations.

### 1. Non-Holonomic vs Quasi-Holonomic Motion

Wheeled differential-drive robots cannot move sideways. Most modern humanoid robots can take side-steps, making them **quasi-holonomic** — they can walk in any horizontal direction, though forward walking is most efficient.

```yaml
# For a humanoid with side-stepping capability:
FollowPath:
  plugin: "dwb_core::DWBLocalPlanner"
  min_vel_y: -0.20     # Allow side-stepping left
  max_vel_y:  0.20     # Allow side-stepping right
  # This requires a holonomic costmap footprint check!
```

### 2. Footstep Planning

For rough terrain, slopes, and stairs, 2D costmap navigation is insufficient. The robot must plan **individual footstep placements** in 3D:

```
2D Costmap Planning:
  Robot → Goal
  Path avoids 2D obstacles
  Ignores terrain height variations

Footstep Planning:
  Robot → Goal
  Each foot is placed explicitly on a valid surface
  Handles stairs, slopes, stepping stones
  Much more computationally expensive
```

A full footstep planner (like **IHMC Footstep Planner** or **OCS2**) is beyond the scope of this chapter, but the interface to Nav2 is a custom **global planner plugin** that outputs a list of `geometry_msgs/Pose` footstep poses.

### 3. Variable-Width Footprint

During walking, a humanoid's footprint is not fixed — it changes with gait phase:

```
Stance phase (double support):   both feet on ground → wide footprint
Swing phase (single support):    one foot in air    → narrow footprint
```

Nav2 supports **footprint inflation** and **footprint topic** (dynamic footprint update):

```yaml
local_costmap:
  local_costmap:
    ros__parameters:
      # Subscribe to dynamic footprint updates
      footprint_topic: /local_footprint
```

```python
# Publish updated footprint based on gait phase
from geometry_msgs.msg import Polygon, Point32

class FootprintPublisher(Node):
    def __init__(self):
        super().__init__('footprint_publisher')
        self.pub = self.create_publisher(
            Polygon, '/local_footprint', 10
        )

    def publish_stance_footprint(self):
        """Wide footprint during double support."""
        poly = Polygon()
        for x, y in [(-0.15, -0.30), (-0.15, 0.30),
                     (0.15, 0.30), (0.15, -0.30)]:
            p = Point32()
            p.x, p.y, p.z = x, y, 0.0
            poly.points.append(p)
        self.pub.publish(poly)

    def publish_swing_footprint(self):
        """Narrow footprint during single support."""
        poly = Polygon()
        for x, y in [(-0.10, -0.15), (-0.10, 0.15),
                     (0.10, 0.15), (0.10, -0.15)]:
            p = Point32()
            p.x, p.y, p.z = x, y, 0.0
            poly.points.append(p)
        self.pub.publish(poly)
```

### 4. Velocity Command Translation

Nav2 outputs `geometry_msgs/Twist` commands (linear velocity + angular velocity). For a wheeled robot, these map directly to wheel speeds. For a humanoid, they must be translated to a **walking gait command**:

```
Nav2 Twist output:
  linear.x = 0.3 m/s   (forward velocity)
  angular.z = 0.5 rad/s (turning rate)

Humanoid Gait Controller input:
  forward_speed = 0.3 m/s
  lateral_speed = 0.0 m/s
  turning_rate  = 0.5 rad/s
  gait_mode     = WALK (vs STAND, CROUCH, RUN)
```

A **Twist → Gait** bridge node sits between Nav2 and the humanoid's locomotion controller:

```python
# twist_to_gait_node.py
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
from std_msgs.msg import Float32MultiArray

class TwistToGaitNode(Node):
    """
    Converts Nav2 Twist commands to humanoid gait parameters.
    Sits between /cmd_vel (Nav2 output) and the gait controller.
    """

    # Gait mode thresholds
    WALK_THRESHOLD = 0.05    # m/s — below this, just rotate in place

    def __init__(self):
        super().__init__('twist_to_gait')

        self.cmd_sub = self.create_subscription(
            Twist, '/cmd_vel', self.cmd_vel_callback, 10
        )

        # Publish to the gait controller
        # Format: [forward_speed, lateral_speed, turning_rate, gait_mode]
        # gait_mode: 0=STAND, 1=WALK, 2=RUN
        self.gait_pub = self.create_publisher(
            Float32MultiArray, '/gait_controller/command', 10
        )

        self.get_logger().info('Twist-to-Gait bridge started.')

    def cmd_vel_callback(self, msg: Twist):
        forward  = msg.linear.x
        lateral  = msg.linear.y
        turn_rate = msg.angular.z

        speed = (forward**2 + lateral**2) ** 0.5

        # Determine gait mode
        if speed < self.WALK_THRESHOLD and abs(turn_rate) < 0.1:
            gait_mode = 0  # STAND
        else:
            gait_mode = 1  # WALK

        gait_cmd = Float32MultiArray()
        gait_cmd.data = [
            float(forward),
            float(lateral),
            float(turn_rate),
            float(gait_mode),
        ]

        self.gait_pub.publish(gait_cmd)

        if gait_mode == 1:
            self.get_logger().debug(
                f'WALK: fwd={forward:.2f} lat={lateral:.2f} '
                f'turn={turn_rate:.2f}'
            )
        else:
            self.get_logger().debug('STAND: zero velocity.')

def main(args=None):
    rclpy.init(args=args)
    node = TwistToGaitNode()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

---

## 4.7 Sending Navigation Goals Programmatically

In Module 1, we used ROS 2 services and topics. Navigation goals use **ROS 2 Actions** — the mechanism for long-running tasks with feedback. The full `NavigateToPose` action client:

```python
# nav2_goal_sender.py
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from nav2_msgs.action import NavigateToPose
from geometry_msgs.msg import PoseStamped, Quaternion
import math

def euler_to_quaternion(yaw: float) -> Quaternion:
    """Convert a yaw angle (radians) to a ROS Quaternion."""
    q = Quaternion()
    q.x = 0.0
    q.y = 0.0
    q.z = math.sin(yaw / 2.0)
    q.w = math.cos(yaw / 2.0)
    return q

class Nav2GoalSender(Node):
    """Sends navigation goals to the Nav2 stack and monitors progress."""

    def __init__(self):
        super().__init__('nav2_goal_sender')
        self._action_client = ActionClient(
            self,
            NavigateToPose,
            'navigate_to_pose'
        )

    def send_goal(self, x: float, y: float, yaw: float):
        """
        Send a 2D navigation goal.
        x, y: target position in the map frame (metres)
        yaw:  target heading (radians, 0 = facing positive X)
        """
        self.get_logger().info(
            f'Waiting for Nav2 action server...'
        )
        self._action_client.wait_for_server()

        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = PoseStamped()
        goal_msg.pose.header.frame_id = 'map'
        goal_msg.pose.header.stamp = self.get_clock().now().to_msg()
        goal_msg.pose.pose.position.x = float(x)
        goal_msg.pose.pose.position.y = float(y)
        goal_msg.pose.pose.position.z = 0.0
        goal_msg.pose.pose.orientation = euler_to_quaternion(yaw)

        self.get_logger().info(
            f'Sending goal: ({x:.2f}, {y:.2f}), yaw={math.degrees(yaw):.1f}°'
        )

        send_goal_future = self._action_client.send_goal_async(
            goal_msg,
            feedback_callback=self.feedback_callback
        )
        send_goal_future.add_done_callback(self.goal_response_callback)

    def goal_response_callback(self, future):
        goal_handle = future.result()
        if not goal_handle.accepted:
            self.get_logger().error('Goal rejected by Nav2!')
            return

        self.get_logger().info('Goal accepted.')
        result_future = goal_handle.get_result_async()
        result_future.add_done_callback(self.result_callback)

    def feedback_callback(self, feedback_msg):
        """Called periodically while the robot navigates."""
        fb = feedback_msg.feedback
        remaining = fb.distance_remaining
        self.get_logger().info(
            f'Distance remaining: {remaining:.2f} m'
        )

    def result_callback(self, future):
        result = future.result().result
        status = future.result().status

        if status == 4:  # SUCCEEDED
            self.get_logger().info('Navigation SUCCEEDED!')
        elif status == 5:  # CANCELED
            self.get_logger().warn('Navigation CANCELED.')
        elif status == 6:  # ABORTED
            self.get_logger().error('Navigation ABORTED (could not reach goal).')

        # Shutdown after reaching goal
        rclpy.shutdown()


def main():
    rclpy.init()
    node = Nav2GoalSender()

    # Example: navigate to position (3.0, 2.0) facing right (0 rad)
    node.send_goal(x=3.0, y=2.0, yaw=0.0)

    rclpy.spin(node)

if __name__ == '__main__':
    main()
```

### Sending a Sequence of Waypoints

```python
# multi_waypoint_nav.py
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from nav2_msgs.action import NavigateThroughPoses
from geometry_msgs.msg import PoseStamped
import math

class WaypointNavigator(Node):
    """Navigate through a list of waypoints in sequence."""

    WAYPOINTS = [
        (2.0, 0.0, 0.0),      # (x, y, yaw)
        (2.0, 2.0, 1.5708),   # Turn left 90°
        (0.0, 2.0, 3.1416),   # Turn left 90° again
        (0.0, 0.0, -1.5708),  # Return home
    ]

    def __init__(self):
        super().__init__('waypoint_navigator')
        self._client = ActionClient(
            self,
            NavigateThroughPoses,
            'navigate_through_poses'
        )

    def navigate(self):
        self._client.wait_for_server()

        goal_msg = NavigateThroughPoses.Goal()
        for x, y, yaw in self.WAYPOINTS:
            pose = PoseStamped()
            pose.header.frame_id = 'map'
            pose.header.stamp = self.get_clock().now().to_msg()
            pose.pose.position.x = x
            pose.pose.position.y = y
            q_z = math.sin(yaw / 2.0)
            q_w = math.cos(yaw / 2.0)
            pose.pose.orientation.z = q_z
            pose.pose.orientation.w = q_w
            goal_msg.poses.append(pose)

        self.get_logger().info(
            f'Navigating through {len(self.WAYPOINTS)} waypoints...'
        )
        future = self._client.send_goal_async(
            goal_msg,
            feedback_callback=self.feedback_cb
        )
        future.add_done_callback(self.goal_accepted_cb)

    def feedback_cb(self, feedback_msg):
        fb = feedback_msg.feedback
        self.get_logger().info(
            f'Waypoints remaining: {fb.number_of_poses_remaining}'
        )

    def goal_accepted_cb(self, future):
        handle = future.result()
        if handle.accepted:
            handle.get_result_async().add_done_callback(self.done_cb)

    def done_cb(self, future):
        self.get_logger().info('Waypoint tour complete!')
        rclpy.shutdown()

def main():
    rclpy.init()
    node = WaypointNavigator()
    node.navigate()
    rclpy.spin(node)

if __name__ == '__main__':
    main()
```

---

## 4.8 Complete Nav2 Configuration File

A production-ready `nav2_params.yaml` for a humanoid robot:

```yaml
# nav2_params.yaml — complete configuration for humanoid robot navigation

bt_navigator:
  ros__parameters:
    global_frame: map
    robot_base_frame: base_link
    odom_topic: /odometry/filtered   # From VSLAM / EKF
    bt_loop_duration: 10             # ms
    default_server_timeout: 20
    # Default behaviour tree (can be overridden per goal)
    default_nav_to_pose_bt_xml: ""   # Empty = use built-in default
    navigators: ['navigate_to_pose', 'navigate_through_poses']
    navigate_to_pose:
      plugin: "nav2_bt_navigator/NavigateToPoseNavigator"
    navigate_through_poses:
      plugin: "nav2_bt_navigator/NavigateThroughPosesNavigator"

planner_server:
  ros__parameters:
    planner_plugins: ["GridBased"]
    GridBased:
      plugin: "nav2_smac_planner/SmacPlannerHybrid"
      tolerance: 0.25
      minimum_turning_radius: 0.20
      allow_unknown: true
      max_iterations: 1000000
      motion_model_for_search: "REEDS_SHEPP"

controller_server:
  ros__parameters:
    controller_frequency: 20.0
    min_x_velocity_threshold: 0.001
    min_y_velocity_threshold: 0.5
    min_theta_velocity_threshold: 0.001
    failure_tolerance: 0.3
    controller_plugins: ["FollowPath"]
    FollowPath:
      plugin: "dwb_core::DWBLocalPlanner"
      debug_trajectory_details: True
      min_vel_x: -0.10
      max_vel_x: 0.50
      min_vel_y: -0.20
      max_vel_y: 0.20
      max_vel_theta: 1.0
      acc_lim_x: 0.5
      acc_lim_theta: 2.5
      sim_time: 1.7
      xy_goal_tolerance: 0.25
      yaw_goal_tolerance: 0.25
      critics: ["RotateToGoal", "Oscillation", "BaseObstacle",
                "GoalAlign", "PathAlign", "PathDist", "GoalDist"]
      PathAlign.scale: 32.0
      GoalAlign.scale: 24.0
      PathDist.scale: 32.0
      GoalDist.scale: 24.0
      RotateToGoal.scale: 32.0

recoveries_server:
  ros__parameters:
    recovery_plugins: ["spin", "backup", "wait"]
    spin:
      plugin: "nav2_recoveries/Spin"
    backup:
      plugin: "nav2_recoveries/BackUp"
    wait:
      plugin: "nav2_recoveries/Wait"
    spin_dist: 1.57          # Radians to spin during recovery
    backup_dist: 0.30        # Metres to back up during recovery
    backup_speed: 0.05       # Metres/sec backup speed
    global_frame: odom
    robot_base_frame: base_link
    simulate_ahead_time: 2.0

map_server:
  ros__parameters:
    yaml_filename: "/maps/building_map.yaml"

amcl:
  ros__parameters:
    use_sim_time: False
    # AMCL is for pre-built maps; swap with VSLAM for unknown environments
    alpha1: 0.2
    alpha2: 0.2
    alpha3: 0.2
    alpha4: 0.2
    alpha5: 0.2
    base_frame_id: base_footprint
    beam_skip_distance: 0.5
    global_frame_id: map
    laser_model_type: likelihood_field
    max_particles: 2000
    min_particles: 500
    odom_frame_id: odom
    set_initial_pose: true
    initial_pose:
      x: 0.0
      y: 0.0
      z: 0.0
      yaw: 0.0
```

---

## 4.9 Launching the Full Navigation Stack

```python
# launch/nav2_humanoid.launch.py
import os
from ament_index_python.packages import get_package_share_directory
from launch import LaunchDescription
from launch.actions import IncludeLaunchDescription, DeclareLaunchArgument
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch.substitutions import LaunchConfiguration
from launch_ros.actions import Node

def generate_launch_description():
    nav2_bringup_dir = get_package_share_directory('nav2_bringup')
    my_pkg_dir = get_package_share_directory('my_robot_pkg')

    params_file = os.path.join(my_pkg_dir, 'config', 'nav2_params.yaml')
    map_file = os.path.join(my_pkg_dir, 'maps', 'building_map.yaml')

    return LaunchDescription([

        # 1. cuVSLAM for localisation
        IncludeLaunchDescription(
            PythonLaunchDescriptionSource(
                os.path.join(
                    get_package_share_directory('isaac_ros_visual_slam'),
                    'launch', 'isaac_ros_visual_slam_realsense.launch.py'
                )
            ),
        ),

        # 2. Nvblox for 3D mapping → 2D costmap
        Node(
            package='nvblox_ros',
            executable='nvblox_node',
            name='nvblox',
            output='screen',
        ),

        # 3. Nav2 bringup (all servers)
        IncludeLaunchDescription(
            PythonLaunchDescriptionSource(
                os.path.join(nav2_bringup_dir, 'launch', 'bringup_launch.py')
            ),
            launch_arguments={
                'map': map_file,
                'params_file': params_file,
                'use_sim_time': 'false',
            }.items(),
        ),

        # 4. Twist → Gait bridge
        Node(
            package='my_robot_pkg',
            executable='twist_to_gait',
            name='twist_to_gait_bridge',
            output='screen',
        ),

        # 5. RViz2 for visualisation
        Node(
            package='rviz2',
            executable='rviz2',
            name='rviz2',
            arguments=[
                '-d', os.path.join(my_pkg_dir, 'config', 'nav2.rviz')
            ],
        ),
    ])
```

---

## 4.10 Chapter Summary

This chapter completed the deployment side of the Module 3 pipeline:

1. **Nav2 architecture**: BT Navigator orchestrates the Planner Server, Controller Server, and Recoveries Server as lifecycle nodes.

2. **Costmaps** translate sensor data into 2D grids of traversal costs. The global costmap covers the whole environment; the local costmap is a fast-updating rolling window around the robot. Configure the **footprint** carefully for humanoid dimensions.

3. **Global planners**: NavFn (A*/Dijkstra, fast, simple) vs Smac Hybrid A* (smooth, kinematically feasible). Use Smac for narrow corridors and humanoids with turning constraints.

4. **Local planners**: DWB (trajectory sampling + critics) provides flexible, tunable local control. Configure `min_vel_y`/`max_vel_y` to enable side-stepping for humanoids.

5. **Humanoid-specific challenges**: quasi-holonomic motion, dynamic footprint, Twist → gait command translation, and eventually footstep planning for rough terrain.

6. **Action API**: Navigation goals are sent via the `NavigateToPose` and `NavigateThroughPoses` ROS 2 action servers. Python action clients with feedback callbacks give full observability.

7. **Full integration**: cuVSLAM → Nvblox → Nav2 → Twist-to-Gait bridge constitutes the complete autonomous navigation pipeline for an Isaac ROS-powered humanoid.

---

## Module 3 Summary

You have completed Module 3: The AI-Robot Brain (NVIDIA Isaac). Across four chapters you have:

- Understood the Omniverse platform, USD scene format, and photorealistic rendering as the foundation for closing the sim-to-real gap
- Built a complete synthetic data generation pipeline with domain randomisation, ground-truth annotators, and COCO export using Isaac Sim Replicator
- Deployed GPU-accelerated cuVSLAM on Jetson Orin for real-time 6-DoF localisation and feature mapping
- Configured and launched the Nav2 navigation stack for bipedal humanoid robots, including costmaps, global/local planners, and recovery behaviours

In Module 4 you will study Vision-Language-Action (VLA) models — the next frontier where end-to-end neural networks directly predict robot actions from images and natural language instructions, replacing the modular pipeline you have built in this module.

---

## Review Questions

1. Draw the Nav2 data flow for the command "navigate to the coffee machine": starting at the Python action client call, trace every component, message type, and topic until the gait controller receives a velocity command.

2. Explain the difference between a global planner and a local planner. Could you use only a global planner without a local planner? What would go wrong if a person stepped into the robot's planned path?

3. A roboticist configures the inflation radius to be exactly equal to the robot's inscribed radius. What dangerous scenario might this cause in a narrow corridor? What value should the inflation radius be relative to the robot's footprint?

4. Your humanoid robot is tasked with navigating through a crowd. The DWB controller keeps oscillating back and forth instead of making progress. Which DWB critic is responsible for penalising oscillation, and what parameter would you increase to make the robot commit to a direction more aggressively?

5. Design the full `nav2_params.yaml` changes needed to make a humanoid robot navigate significantly more conservatively — slower, with wider clearance from obstacles, and more willing to take longer paths to avoid tight spaces. List every parameter you would change and its new value, with a one-line justification for each.
