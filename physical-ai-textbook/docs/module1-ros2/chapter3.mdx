---
title: "Chapter 3: Building ROS 2 Packages"
sidebar_position: 3
---

import TranslateButton from '@site/src/components/TranslateButton';
import PersonalizeButton from '@site/src/components/PersonalizeButton';

<TranslateButton />
<PersonalizeButton />

# Chapter 3: Building ROS 2 Packages

## Learning Objectives

By the end of this chapter, you will be able to:

- Explain the role of a ROS 2 package and a workspace
- Create a Python-based (`ament_python`) ROS 2 package from scratch
- Understand the key files: `package.xml`, `setup.py`, and `setup.cfg`
- Create and register node entry points so nodes can be run with `ros2 run`
- Define custom message and service types in a separate package
- Write launch files using the Python launch API to start multiple nodes together
- Build and test a workspace using `colcon`

---

## 3.1 Workspaces and Packages

### The Workspace

A **workspace** is a directory on your filesystem where you develop and build ROS 2 software. It has a specific structure:

```
my_workspace/                  ← Workspace root
├── src/                       ← All source packages go here
│   ├── my_robot_pkg/          ← Package A
│   └── my_interfaces_pkg/     ← Package B
├── build/                     ← Created by colcon (compiled artefacts)
├── install/                   ← Created by colcon (installed files)
└── log/                       ← Build logs
```

The `src/` directory is the only part you create manually. `build/`, `install/`, and `log/` are generated by the build tool `colcon`.

### The Package

A **package** is the basic unit of distribution in ROS 2. Every package must contain at minimum a `package.xml` manifest file. Packages can be:

- **Python packages** (`ament_python`) — use `setup.py` + `setup.cfg`
- **C++ packages** (`ament_cmake`) — use `CMakeLists.txt`
- **Mixed packages** (`ament_cmake_python`) — both, for advanced use cases

For AI and Python developers, `ament_python` is the correct choice.

---

## 3.2 Creating a Python Package

### Step 1: Create the Workspace

```bash
mkdir -p ~/ros2_ws/src
cd ~/ros2_ws
```

### Step 2: Create the Package

```bash
cd ~/ros2_ws/src

# Syntax: ros2 pkg create --build-type ament_python \
#         --dependencies rclpy <package_name>

ros2 pkg create --build-type ament_python \
    --dependencies rclpy geometry_msgs std_msgs \
    my_robot_pkg
```

This command generates the following structure:

```
my_robot_pkg/
├── package.xml
├── setup.py
├── setup.cfg
├── resource/
│   └── my_robot_pkg          ← Marker file (do not delete)
├── test/
│   ├── test_copyright.py
│   ├── test_flake8.py
│   └── test_pep257.py
└── my_robot_pkg/             ← Python package directory
    └── __init__.py
```

---

## 3.3 Anatomy of a Python Package

### `package.xml` — The Manifest

`package.xml` describes your package to the ROS 2 tooling. It contains metadata, build type, and dependencies:

```xml
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd"
            schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>my_robot_pkg</name>
  <version>0.1.0</version>
  <description>
    A ROS 2 Python package for controlling my robot.
  </description>

  <maintainer email="you@example.com">Your Name</maintainer>
  <license>Apache-2.0</license>

  <!-- Build system -->
  <buildtool_depend>ament_python</buildtool_depend>

  <!-- Runtime dependencies (what your nodes import) -->
  <depend>rclpy</depend>
  <depend>geometry_msgs</depend>
  <depend>std_msgs</depend>
  <depend>sensor_msgs</depend>

  <!-- Test dependencies -->
  <test_depend>ament_lint_auto</test_depend>
  <test_depend>ament_lint_common</test_depend>

  <export>
    <build_type>ament_python</build_type>
  </export>
</package>
```

**Dependency types:**
- `<depend>` — needed at build and runtime (use for Python imports)
- `<build_depend>` — only needed at build time (code generators, compilers)
- `<exec_depend>` — only needed at runtime
- `<test_depend>` — only needed for tests

### `setup.py` — Entry Points

`setup.py` is where you tell ROS 2 how to install your package and, critically, **register your nodes as executable entry points**:

```python
from setuptools import find_packages, setup
import os
from glob import glob

package_name = 'my_robot_pkg'

setup(
    name=package_name,
    version='0.1.0',
    packages=find_packages(exclude=['test']),
    data_files=[
        # Required: installs the marker file for ament
        ('share/ament_index/resource_index/packages',
            ['resource/' + package_name]),
        # Required: installs package.xml
        ('share/' + package_name, ['package.xml']),
        # Install launch files (we'll create these later)
        (os.path.join('share', package_name, 'launch'),
            glob(os.path.join('launch', '*.launch.py'))),
        # Install config files
        (os.path.join('share', package_name, 'config'),
            glob(os.path.join('config', '*.yaml'))),
    ],
    install_requires=['setuptools'],
    zip_safe=True,
    maintainer='Your Name',
    maintainer_email='you@example.com',
    description='A ROS 2 Python package for controlling my robot.',
    license='Apache-2.0',
    tests_require=['pytest'],
    entry_points={
        'console_scripts': [
            # Format: 'command_name = package.module:function'
            'temperature_sensor = my_robot_pkg.temperature_publisher:main',
            'temperature_monitor = my_robot_pkg.temperature_monitor:main',
            'robot_driver = my_robot_pkg.robot_driver:main',
        ],
    },
)
```

After building, entry points allow:

```bash
ros2 run my_robot_pkg temperature_sensor
ros2 run my_robot_pkg robot_driver
```

### `setup.cfg` — Build Configuration

```ini
[develop]
script_dir=$base/lib/my_robot_pkg

[install]
install_scripts=$base/lib/my_robot_pkg
```

This file tells `colcon` where to install the executable scripts. Do not modify it.

---

## 3.4 Adding Your Node Files

Place all your Python source files inside the `my_robot_pkg/` subdirectory (the one containing `__init__.py`):

```
my_robot_pkg/
└── my_robot_pkg/
    ├── __init__.py
    ├── temperature_publisher.py    ← Our publisher from Chapter 2
    ├── temperature_monitor.py      ← Our subscriber from Chapter 2
    ├── robot_driver.py             ← Our velocity commander
    └── sensor_fusion_node.py       ← Our fusion node
```

Copy the node code from Chapter 2 into these files. Each file has its own `main()` function, which is the entry point registered in `setup.py`.

---

## 3.5 Custom Message and Service Types

The standard messages in `std_msgs` and `geometry_msgs` cover most cases, but for a professional project you will define your own types. Custom interfaces are always placed in a **separate package** (`ament_cmake` build type, because the code generation tools use CMake).

### Create the Interfaces Package

```bash
cd ~/ros2_ws/src
ros2 pkg create --build-type ament_cmake my_robot_interfaces
```

### Directory Structure for Interfaces

```
my_robot_interfaces/
├── package.xml
├── CMakeLists.txt
├── msg/
│   ├── RobotStatus.msg
│   └── JointState.msg
└── srv/
    ├── MoveToPosition.srv
    └── GetBatteryLevel.srv
```

### Defining a Custom Message: `RobotStatus.msg`

Message fields use the syntax `type field_name [= default_value]`. Use `#` for comments:

```
# RobotStatus.msg
# Represents the overall status of the robot

std_msgs/Header header     # Timestamp and frame ID

# Robot identity
string robot_id
string model_name

# Motion state
float64 battery_level      # Percentage [0.0, 100.0]
bool is_charging

# Current velocity
geometry_msgs/Twist velocity

# Operational mode
uint8 MODE_IDLE = 0
uint8 MODE_NAVIGATING = 1
uint8 MODE_MANIPULATING = 2
uint8 MODE_EMERGENCY_STOP = 3
uint8 mode
```

### Defining a Custom Service: `MoveToPosition.srv`

```
# MoveToPosition.srv
# Request: where to move
geometry_msgs/Pose target_pose
float64 max_speed          # m/s
bool avoid_obstacles       # Use obstacle avoidance planner
---
# Response: result of the move
bool success
string message
float64 distance_travelled # metres
float64 time_elapsed       # seconds
```

### `CMakeLists.txt` for Interface Package

```cmake
cmake_minimum_required(VERSION 3.8)
project(my_robot_interfaces)

# Find dependencies
find_package(ament_cmake REQUIRED)
find_package(rosidl_default_generators REQUIRED)
find_package(std_msgs REQUIRED)
find_package(geometry_msgs REQUIRED)

# Generate messages and services from .msg / .srv files
rosidl_generate_interfaces(${PROJECT_NAME}
  "msg/RobotStatus.msg"
  "msg/JointState.msg"
  "srv/MoveToPosition.srv"
  "srv/GetBatteryLevel.srv"
  DEPENDENCIES std_msgs geometry_msgs
)

ament_export_dependencies(rosidl_default_runtime)
ament_package()
```

### `package.xml` for Interface Package

```xml
<?xml version="1.0"?>
<package format="3">
  <name>my_robot_interfaces</name>
  <version>0.1.0</version>
  <description>Custom message and service types for my robot.</description>
  <maintainer email="you@example.com">Your Name</maintainer>
  <license>Apache-2.0</license>

  <buildtool_depend>ament_cmake</buildtool_depend>
  <buildtool_depend>rosidl_default_generators</buildtool_depend>

  <depend>std_msgs</depend>
  <depend>geometry_msgs</depend>

  <exec_depend>rosidl_default_runtime</exec_depend>

  <member_of_group>rosidl_interface_packages</member_of_group>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package>
```

### Using Custom Messages in Python

```python
# In your node file:
from my_robot_interfaces.msg import RobotStatus
from my_robot_interfaces.srv import MoveToPosition

# Publishing a RobotStatus
status_pub = self.create_publisher(RobotStatus, '/robot/status', 10)

msg = RobotStatus()
msg.header.stamp = self.get_clock().now().to_msg()
msg.robot_id = 'robot_001'
msg.battery_level = 87.3
msg.mode = RobotStatus.MODE_NAVIGATING

status_pub.publish(msg)
```

---

## 3.6 Building with Colcon

`colcon` is the ROS 2 build tool. It scans your `src/` directory, resolves inter-package dependencies, and builds everything in the correct order.

### First Build

```bash
cd ~/ros2_ws

# Build all packages
colcon build

# Build only specific packages (faster for large workspaces)
colcon build --packages-select my_robot_pkg my_robot_interfaces

# Build with symlinks (changes to Python files take effect without rebuilding)
colcon build --symlink-install
```

After building, source the workspace:

```bash
source ~/ros2_ws/install/setup.bash

# Add to ~/.bashrc so it is sourced automatically in every new terminal:
echo "source ~/ros2_ws/install/setup.bash" >> ~/.bashrc
```

### Understanding the Build Output

```
~/ros2_ws/install/my_robot_pkg/
├── lib/
│   └── my_robot_pkg/
│       ├── temperature_sensor    ← Installed executable (from entry_points)
│       └── robot_driver
├── share/
│   └── my_robot_pkg/
│       ├── package.xml
│       └── launch/
│           └── full_robot.launch.py
```

### Common Colcon Options

```bash
# Run tests after building
colcon test --packages-select my_robot_pkg

# See test results
colcon test-result --verbose

# Clean build artefacts (like 'make clean')
rm -rf build/ install/ log/

# Skip a package
colcon build --packages-skip my_robot_interfaces
```

---

## 3.7 Launch Files

Running a full robot system means starting dozens of nodes simultaneously. **Launch files** automate this. ROS 2 uses a Python-based launch API.

### A Simple Launch File

Create `launch/robot.launch.py` inside your package:

```python
# launch/robot.launch.py
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    """
    This function is the entry point for the launch system.
    It must return a LaunchDescription object.
    """
    return LaunchDescription([

        # Start the temperature sensor node
        Node(
            package='my_robot_pkg',
            executable='temperature_sensor',
            name='temp_sensor_node',           # Remaps node name
            output='screen',                   # Log to terminal
        ),

        # Start the temperature monitor node
        Node(
            package='my_robot_pkg',
            executable='temperature_monitor',
            name='temp_monitor_node',
            output='screen',
        ),

        # Start the robot driver with a custom parameter
        Node(
            package='my_robot_pkg',
            executable='robot_driver',
            name='driver_node',
            output='screen',
            parameters=[{'max_speed': 1.5}],
        ),
    ])
```

Run the launch file:

```bash
ros2 launch my_robot_pkg robot.launch.py
```

### Advanced Launch Features

Launch files support arguments, remapping, namespacing, and conditional logic:

```python
# launch/full_robot.launch.py
import os
from launch import LaunchDescription
from launch.actions import (
    DeclareLaunchArgument,
    GroupAction,
    IncludeLaunchDescription,
    LogInfo,
)
from launch.conditions import IfCondition
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch.substitutions import LaunchConfiguration, PathJoinSubstitution
from launch_ros.actions import Node, PushRosNamespace
from ament_index_python.packages import get_package_share_directory

def generate_launch_description():

    # --- Declare launch arguments ---
    use_sim_arg = DeclareLaunchArgument(
        'use_sim',
        default_value='false',
        description='Launch in simulation mode'
    )
    robot_name_arg = DeclareLaunchArgument(
        'robot_name',
        default_value='my_robot',
        description='Name of the robot (used for namespacing)'
    )

    use_sim = LaunchConfiguration('use_sim')
    robot_name = LaunchConfiguration('robot_name')

    # --- Nodes ---
    sensor_node = Node(
        package='my_robot_pkg',
        executable='temperature_sensor',
        output='screen',
        # Remap: change topic names at launch without modifying code
        remappings=[
            ('/temperature', '/robot/temperature'),
        ],
        # Load parameters from a YAML file
        parameters=[
            os.path.join(
                get_package_share_directory('my_robot_pkg'),
                'config', 'sensor_params.yaml'
            )
        ],
    )

    monitor_node = Node(
        package='my_robot_pkg',
        executable='temperature_monitor',
        output='screen',
        remappings=[('/temperature', '/robot/temperature')],
    )

    # This node only launches if use_sim:=true
    sim_node = Node(
        package='my_robot_pkg',
        executable='robot_driver',
        output='screen',
        condition=IfCondition(use_sim),
    )

    # Group nodes under a namespace (all topics prefixed with /my_robot/)
    namespaced_group = GroupAction([
        PushRosNamespace(robot_name),
        sensor_node,
        monitor_node,
    ])

    return LaunchDescription([
        use_sim_arg,
        robot_name_arg,
        LogInfo(msg=['Launching robot: ', robot_name]),
        namespaced_group,
        sim_node,
    ])
```

Run with arguments:

```bash
ros2 launch my_robot_pkg full_robot.launch.py use_sim:=true robot_name:=atlas
```

---

## 3.8 Parameter Files (YAML)

For complex configurations, store parameters in a YAML file rather than hardcoding them in the launch file:

```yaml
# config/sensor_params.yaml
/temperature_sensor:
  ros__parameters:
    publish_rate: 5.0          # Hz
    min_temp: 35.0             # °C
    max_temp: 42.0             # °C
    sensor_id: "sensor_left_arm"

/temperature_monitor:
  ros__parameters:
    fever_threshold: 38.5      # °C
    alert_cooldown: 5.0        # seconds between alerts
```

Load in launch file:

```python
Node(
    package='my_robot_pkg',
    executable='temperature_sensor',
    parameters=[os.path.join(pkg_share, 'config', 'sensor_params.yaml')],
)
```

Or on the command line:

```bash
ros2 run my_robot_pkg temperature_sensor \
    --ros-args --params-file config/sensor_params.yaml
```

---

## 3.9 Testing Your Package

ROS 2 uses `pytest` for Python tests. Tests live in the `test/` directory.

### Writing a Node Unit Test

```python
# test/test_temperature_publisher.py
import pytest
import rclpy
from rclpy.node import Node
from std_msgs.msg import Float64
from my_robot_pkg.temperature_publisher import TemperatureSensor

@pytest.fixture(autouse=True)
def ros_context():
    rclpy.init()
    yield
    rclpy.shutdown()

def test_temperature_in_valid_range():
    """Test that published temperatures are within expected bounds."""
    node = TemperatureSensor()

    received_messages = []

    # Create a helper subscriber
    test_node = Node('test_node')
    test_node.create_subscription(
        Float64,
        '/temperature',
        lambda msg: received_messages.append(msg.data),
        10
    )

    # Spin for a short time to receive a message
    import time
    end_time = time.time() + 3.0
    while time.time() < end_time and len(received_messages) == 0:
        rclpy.spin_once(node, timeout_sec=0.1)
        rclpy.spin_once(test_node, timeout_sec=0.1)

    node.destroy_node()
    test_node.destroy_node()

    assert len(received_messages) > 0, "No temperature messages received"
    for temp in received_messages:
        assert 36.0 <= temp <= 40.0, f"Temperature {temp} out of range"

def test_node_name():
    node = TemperatureSensor()
    assert node.get_name() == 'temperature_sensor'
    node.destroy_node()
```

Run tests:

```bash
colcon test --packages-select my_robot_pkg
colcon test-result --verbose
```

---

## 3.10 Complete Package Checklist

Before releasing a ROS 2 package, verify:

```
✅  package.xml has correct name, version, maintainer, license
✅  All Python imports appear as <depend> in package.xml
✅  All node entry points registered in setup.py console_scripts
✅  setup.py includes data_files for launch/ and config/ directories
✅  Launch file starts all required nodes
✅  Parameter YAML file covers all tunable values
✅  At least one test per node in test/
✅  colcon build --packages-select <name> succeeds with no warnings
✅  colcon test --packages-select <name> passes
✅  ros2 run <pkg> <node> works after sourcing install/setup.bash
```

---

## 3.11 Chapter Summary

This chapter gave you the skills to structure professional ROS 2 projects:

1. **Workspaces** separate source code from build artefacts. Always work inside `~/ros2_ws/src/`.

2. **Python packages** (`ament_python`) require `package.xml` (metadata), `setup.py` (entry points and data files), and `setup.cfg` (install paths).

3. **Custom interfaces** go in a separate `ament_cmake` package. Messages (`.msg`) define topic types; services (`.srv`) define service types.

4. **`colcon build`** resolves dependencies and builds all packages. Always use `--symlink-install` during development to avoid rebuilding after every Python change.

5. **Launch files** orchestrate multi-node systems with arguments, remappings, namespaces, and conditional logic.

6. **Parameter YAML files** externalise configuration and are loaded at launch time.

7. **Tests** use `pytest` and are run with `colcon test`.

---

## Review Questions

1. Why are custom message types defined in a separate `ament_cmake` package instead of inside your `ament_python` application package?

2. What is the purpose of the `entry_points` section in `setup.py`? What would happen if you forgot to register a node there?

3. Write the `package.xml` for a package called `arm_controller_pkg` that depends on `rclpy`, `sensor_msgs`, and a custom package called `my_robot_interfaces`.

4. Explain the difference between these two colcon commands:
   - `colcon build`
   - `colcon build --symlink-install`
   When would you use each one?

5. Write a launch file that starts two nodes — `camera_driver` from `camera_pkg` and `object_detector` from `vision_pkg` — where both are placed under the namespace `/robot_1`, and the object detector receives a launch argument `model_path` that defaults to `/models/yolo.pt`.
